/**
 * Shared Types Unit Tests
 * 
 * Tests for the unified type system validation
 */

import { describe, test, expect } from 'vitest'
import { 
  UnifiedVideoReference,
  UnifiedChatResponse,
  TodoSuggestion,
  CalendarAction,
  LearningPathSegment,
  TodoVideoLink,
  ProgressSyncEvent,
  ServiceResponse,
  IntegrationConfig
} from '../../src/types/shared'

describe('Shared Types Validation', () => {
  describe('UnifiedVideoReference', () => {
    test('should accept valid unified video reference', () => {
      const videoRef: UnifiedVideoReference = {
        videoId: 'vid-001',
        youtubeId: 'dQw4w9WgXcQ',
        title: 'Test Video',
        thumbnailUrl: 'https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg',
        creatorName: 'TestCreator',
        timestamp: '15:30',
        timestampSeconds: 930,
        relevantSegment: 'This is the relevant part',
        confidence: 0.95,
        transcriptChunkId: 'chunk-001',
        duration: 1200,
        watchProgress: 65,
        linkedTodoIds: ['todo-001'],
        learningObjectives: ['Learn X', 'Practice Y'],
        videoUrl: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ',
        timestampUrl: 'https://www.youtube.com/watch?v=dQw4w9WgXcQ&t=930s',
        addedAt: '2024-09-02T10:00:00Z',
        lastWatched: '2024-09-02T14:30:00Z'
      }

      expect(videoRef.videoId).toBe('vid-001')
      expect(videoRef.youtubeId).toBe('dQw4w9WgXcQ')
      expect(videoRef.timestampSeconds).toBe(930)
      expect(videoRef.watchProgress).toBe(65)
      expect(videoRef.linkedTodoIds).toHaveLength(1)
    })

    test('should work with minimal required fields', () => {
      const minimalVideoRef: UnifiedVideoReference = {
        videoId: 'vid-minimal',
        youtubeId: 'abc123',
        title: 'Minimal Video',
        thumbnailUrl: 'https://img.youtube.com/vi/abc123/maxresdefault.jpg'
      }

      expect(minimalVideoRef.videoId).toBe('vid-minimal')
      expect(minimalVideoRef.creatorName).toBeUndefined()
      expect(minimalVideoRef.timestamp).toBeUndefined()
    })
  })

  describe('UnifiedChatResponse', () => {
    test('should accept complete chat response with integration fields', () => {
      const chatResponse: UnifiedChatResponse = {
        answer: 'Here is your answer about Lua variables...',
        videoReferences: [],
        suggestedQuestions: ['How do I create functions?'],
        sessionId: 'session-001',
        responseTime: 1250,
        suggestedTodos: [],
        schedulingActions: [],
        learningPath: [],
        actionButtons: [],
        metadata: {
          cacheHit: false,
          searchResultsCount: 5,
          confidence: 0.91,
          tokensUsed: 1200,
          intent: {
            primary: 'learn',
            secondary: ['practice'],
            confidence: 0.95,
            extractedEntities: {
              concepts: ['variables', 'lua'],
              actions: ['create', 'practice']
            }
          }
        }
      }

      expect(chatResponse.answer).toContain('Lua variables')
      expect(chatResponse.suggestedTodos).toEqual([])
      expect(chatResponse.metadata.intent?.primary).toBe('learn')
      expect(chatResponse.metadata.tokensUsed).toBe(1200)
    })
  })

  describe('TodoSuggestion', () => {
    test('should validate todo suggestion structure', () => {
      const todoSuggestion: TodoSuggestion = {
        title: 'Practice Variable Creation',
        description: 'Create 5 different variable types',
        priority: 'medium',
        category: 'practice',
        estimatedMinutes: 30,
        videoReferences: [],
        suggestedDueDate: '2024-09-03T10:00:00Z',
        prerequisites: ['Watch basics video'],
        learningObjectives: ['Variable syntax', 'Data types'],
        autoGenerated: true,
        confidence: 0.92
      }

      expect(todoSuggestion.title).toBe('Practice Variable Creation')
      expect(todoSuggestion.priority).toBe('medium')
      expect(todoSuggestion.category).toBe('practice')
      expect(todoSuggestion.autoGenerated).toBe(true)
      expect(todoSuggestion.confidence).toBe(0.92)
    })

    test('should accept valid priority and category values', () => {
      const priorities: Array<TodoSuggestion['priority']> = ['low', 'medium', 'high', 'urgent']
      const categories: Array<TodoSuggestion['category']> = ['practice', 'learn', 'build', 'review', 'other']

      priorities.forEach(priority => {
        const todo: TodoSuggestion = {
          title: 'Test',
          priority,
          category: 'practice',
          estimatedMinutes: 30,
          videoReferences: [],
          autoGenerated: true,
          confidence: 0.8
        }
        expect(todo.priority).toBe(priority)
      })

      categories.forEach(category => {
        const todo: TodoSuggestion = {
          title: 'Test',
          priority: 'medium',
          category,
          estimatedMinutes: 30,
          videoReferences: [],
          autoGenerated: true,
          confidence: 0.8
        }
        expect(todo.category).toBe(category)
      })
    })
  })

  describe('CalendarAction', () => {
    test('should validate calendar action types', () => {
      const actions: Array<CalendarAction['type']> = [
        'schedule_video',
        'schedule_practice', 
        'schedule_review',
        'block_time'
      ]

      actions.forEach(type => {
        const action: CalendarAction = {
          type,
          title: 'Test Action',
          duration: 60
        }
        expect(action.type).toBe(type)
      })
    })

    test('should support recurring patterns', () => {
      const action: CalendarAction = {
        type: 'schedule_video',
        title: 'Weekly Review',
        duration: 60,
        recurring: {
          frequency: 'weekly',
          interval: 1,
          daysOfWeek: [1, 3, 5], // Mon, Wed, Fri
          endDate: '2024-12-31T23:59:59Z',
          maxOccurrences: 52
        }
      }

      expect(action.recurring?.frequency).toBe('weekly')
      expect(action.recurring?.daysOfWeek).toHaveLength(3)
      expect(action.recurring?.maxOccurrences).toBe(52)
    })
  })

  describe('LearningPathSegment', () => {
    test('should validate learning path segment structure', () => {
      const segment: LearningPathSegment = {
        id: 'segment-001',
        order: 1,
        title: 'Lua Basics',
        description: 'Learn fundamental Lua concepts',
        type: 'video',
        estimatedMinutes: 45,
        videoReferences: [],
        prerequisites: [],
        objectives: ['Variables', 'Functions'],
        completed: false,
        completedAt: undefined
      }

      expect(segment.order).toBe(1)
      expect(segment.type).toBe('video')
      expect(segment.completed).toBe(false)
      expect(segment.objectives).toHaveLength(2)
    })

    test('should support different segment types', () => {
      const types: Array<LearningPathSegment['type']> = ['video', 'practice', 'project', 'quiz']

      types.forEach(type => {
        const segment: LearningPathSegment = {
          id: `segment-${type}`,
          order: 1,
          title: `${type} segment`,
          description: 'Test segment',
          type,
          estimatedMinutes: 30,
          videoReferences: [],
          prerequisites: [],
          objectives: [],
          completed: false
        }
        expect(segment.type).toBe(type)
      })
    })
  })

  describe('TodoVideoLink', () => {
    test('should validate todo-video link structure', () => {
      const link: TodoVideoLink = {
        id: 'link-001',
        todoId: 'todo-001',
        videoReference: {
          videoId: 'vid-001',
          youtubeId: 'abc123',
          title: 'Test Video',
          thumbnailUrl: 'https://example.com/thumb.jpg'
        },
        linkType: 'reference',
        addedAt: '2024-09-02T10:00:00Z',
        addedBy: 'ai',
        notes: 'Auto-linked based on content relevance'
      }

      expect(link.linkType).toBe('reference')
      expect(link.addedBy).toBe('ai')
      expect(link.notes).toContain('relevance')
    })

    test('should support different link types', () => {
      const linkTypes: Array<TodoVideoLink['linkType']> = ['reference', 'requirement', 'output']
      const addedBy: Array<TodoVideoLink['addedBy']> = ['user', 'ai', 'system']

      linkTypes.forEach(linkType => {
        const link: TodoVideoLink = {
          id: 'test-link',
          todoId: 'test-todo',
          videoReference: {
            videoId: 'test-vid',
            youtubeId: 'test-yt',
            title: 'Test',
            thumbnailUrl: 'test.jpg'
          },
          linkType,
          addedAt: new Date().toISOString(),
          addedBy: 'ai'
        }
        expect(link.linkType).toBe(linkType)
      })
    })
  })

  describe('ProgressSyncEvent', () => {
    test('should validate progress sync event structure', () => {
      const event: ProgressSyncEvent = {
        type: 'video_watched',
        userId: 'user-001',
        timestamp: '2024-09-02T14:30:00Z',
        source: 'video_player',
        data: {
          youtubeId: 'abc123',
          watchedSeconds: 900,
          totalSeconds: 1200,
          completed: false
        },
        relatedEntities: {
          videoIds: ['vid-001'],
          todoIds: ['todo-001']
        }
      }

      expect(event.type).toBe('video_watched')
      expect(event.source).toBe('video_player')
      expect(event.data.watchedSeconds).toBe(900)
      expect(event.relatedEntities.videoIds).toHaveLength(1)
    })

    test('should support different event types and sources', () => {
      const eventTypes: Array<ProgressSyncEvent['type']> = [
        'video_watched',
        'todo_completed',
        'path_advanced',
        'milestone_reached'
      ]

      const sources: Array<ProgressSyncEvent['source']> = [
        'video_player',
        'todo_system',
        'calendar',
        'chat'
      ]

      eventTypes.forEach(type => {
        const event: ProgressSyncEvent = {
          type,
          userId: 'test-user',
          timestamp: new Date().toISOString(),
          source: 'video_player',
          data: {},
          relatedEntities: {}
        }
        expect(event.type).toBe(type)
      })

      sources.forEach(source => {
        const event: ProgressSyncEvent = {
          type: 'video_watched',
          userId: 'test-user',
          timestamp: new Date().toISOString(),
          source,
          data: {},
          relatedEntities: {}
        }
        expect(event.source).toBe(source)
      })
    })
  })

  describe('ServiceResponse', () => {
    test('should validate successful service response', () => {
      const response: ServiceResponse<string> = {
        success: true,
        data: 'test-result',
        timestamp: '2024-09-02T10:00:00Z',
        source: 'TestService'
      }

      expect(response.success).toBe(true)
      expect(response.data).toBe('test-result')
      expect(response.error).toBeUndefined()
    })

    test('should validate error service response', () => {
      const response: ServiceResponse<null> = {
        success: false,
        error: 'Something went wrong',
        timestamp: '2024-09-02T10:00:00Z',
        source: 'TestService'
      }

      expect(response.success).toBe(false)
      expect(response.error).toBe('Something went wrong')
      expect(response.data).toBeUndefined()
    })
  })

  describe('IntegrationConfig', () => {
    test('should validate complete integration config', () => {
      const config: IntegrationConfig = {
        openaiApiKey: 'sk-test-key',
        openaiModel: 'gpt-4o-mini',
        embeddingModel: 'text-embedding-3-small',
        enableTodoGeneration: true,
        enableSmartScheduling: true,
        enableLearningPaths: true,
        enableProgressSync: true,
        maxVideoReferences: 5,
        maxTodoSuggestions: 3,
        cacheTimeoutMinutes: 60,
        defaultTodoPriority: 'medium',
        defaultSchedulingDuration: 60,
        autoLinkVideosToTodos: true
      }

      expect(config.openaiApiKey).toContain('sk-')
      expect(config.openaiModel).toBe('gpt-4o-mini')
      expect(config.maxVideoReferences).toBe(5)
      expect(config.defaultTodoPriority).toBe('medium')
      expect(typeof config.autoLinkVideosToTodos).toBe('boolean')
    })
  })
})

describe('Type Compatibility Tests', () => {
  test('should ensure backward compatibility with existing types', () => {
    // Test that UnifiedVideoReference can be used where VideoReference was expected
    const unifiedRef: UnifiedVideoReference = {
      videoId: 'vid-001',
      youtubeId: 'abc123',
      title: 'Test Video',
      thumbnailUrl: 'thumb.jpg',
      timestamp: '10:30',
      confidence: 0.9
    }

    // This should work with both old and new systems
    expect(unifiedRef.videoId).toBeDefined()
    expect(unifiedRef.youtubeId).toBeDefined()
    expect(unifiedRef.title).toBeDefined()
    expect(unifiedRef.thumbnailUrl).toBeDefined()
  })

  test('should handle optional fields gracefully', () => {
    const partialRef: Partial<UnifiedVideoReference> = {
      videoId: 'vid-partial',
      youtubeId: 'partial123'
    }

    // TypeScript should allow this
    expect(partialRef.videoId).toBe('vid-partial')
    expect(partialRef.title).toBeUndefined()
  })

  test('should validate nested object structures', () => {
    const chatResponse: UnifiedChatResponse = {
      answer: 'Test answer',
      videoReferences: [{
        videoId: 'nested-vid',
        youtubeId: 'nested123',
        title: 'Nested Video',
        thumbnailUrl: 'nested-thumb.jpg'
      }],
      suggestedQuestions: [],
      sessionId: 'test-session',
      responseTime: 1000,
      metadata: {
        cacheHit: false,
        searchResultsCount: 1,
        confidence: 0.8,
        intent: {
          primary: 'question',
          confidence: 0.9
        }
      }
    }

    expect(chatResponse.videoReferences[0].videoId).toBe('nested-vid')
    expect(chatResponse.metadata.intent?.primary).toBe('question')
  })
})