{
  "meta": {
    "instanceId": "interaction-tracker-workflow"
  },
  "nodes": [
    {
      "id": "interaction-webhook",
      "name": "üìä Interaction Event Webhook",
      "type": "n8n-nodes-base.webhook",
      "position": [240, 300],
      "parameters": {
        "path": "track-interaction",
        "httpMethod": "POST",
        "responseMode": "responseNode"
      },
      "typeVersion": 2.1,
      "onError": "continueRegularOutput",
      "webhookId": "interaction-tracker",
      "notes": "üìä USER INTERACTION TRACKING ENTRY POINT\n\nüìù Purpose: Receives all user interaction events for pattern analysis\n\nüìã Expected Event Types & Payloads:\n‚Ä¢ VIDEO_WATCH: { videoId, watchTime, completed, timestamp }\n‚Ä¢ CHAT_QUERY: { query, response, satisfaction, timestamp }\n‚Ä¢ TASK_COMPLETE: { taskId, timeSpent, difficulty, success }\n‚Ä¢ HELP_REQUEST: { topic, method, resolved, timestamp }\n‚Ä¢ NAVIGATION: { fromPage, toPage, timeSpent, timestamp }\n‚Ä¢ QUIZ_ATTEMPT: { quizId, score, attempts, timestamp }\n‚Ä¢ COMMUNITY_POST: { postType, engagement, timestamp }\n\nüîó Integration Points:\n‚Ä¢ Platform UI sends events via JavaScript\n‚Ä¢ Mobile app analytics integration\n‚Ä¢ Server-side action tracking\n‚Ä¢ Third-party tool integrations\n\n‚ö° Response: Immediate acknowledgment for real-time UX"
    },    {
      "id": "event-validator",
      "name": "‚úÖ Event Validator",
      "type": "n8n-nodes-base.code",
      "position": [460, 300],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Event Validation and Sanitization\n// Ensures interaction events meet quality standards and security requirements\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  try {\n    const body = item.json.body || {};\n    const {\n      eventType = '',\n      userId = '',\n      sessionId = '',\n      timestamp = new Date().toISOString(),\n      data = {},\n      userAgent = '',\n      ipAddress = ''\n    } = body;\n\n    // Validation checks\n    const errors = [];\n    \n    if (!eventType || typeof eventType !== 'string') {\n      errors.push('eventType is required and must be a string');\n    }\n    \n    if (!userId || typeof userId !== 'string') {\n      errors.push('userId is required and must be a string');\n    }\n    \n    if (!sessionId || typeof sessionId !== 'string') {\n      errors.push('sessionId is required and must be a string');\n    }\n    \n    // Validate timestamp format\n    if (timestamp && isNaN(Date.parse(timestamp))) {\n      errors.push('timestamp must be a valid ISO-8601 date string');\n    }\n    \n    // Security sanitization\n    const sanitizedData = {};\n    for (const [key, value] of Object.entries(data)) {\n      // Remove potential XSS and injection attempts\n      if (typeof value === 'string') {\n        sanitizedData[key] = value\n          .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n          .replace(/<[^>]*>/g, '')\n          .substring(0, 1000); // Limit length\n      } else if (typeof value === 'number' && !isNaN(value)) {\n        sanitizedData[key] = value;\n      } else if (typeof value === 'boolean') {\n        sanitizedData[key] = value;\n      }\n      // Skip objects, arrays, and other complex types for security\n    }\n    \n    if (errors.length > 0) {\n      results.push({\n        json: {\n          success: false,\n          error: 'Validation failed',\n          details: errors,\n          timestamp: new Date().toISOString()\n        }\n      });\n      continue;\n    }\n    \n    // Create validated event\n    const validatedEvent = {\n      eventType: eventType.toUpperCase(),\n      userId,\n      sessionId,\n      timestamp: timestamp || new Date().toISOString(),\n      data: sanitizedData,\n      metadata: {\n        userAgent: userAgent.substring(0, 500),\n        ipAddress: ipAddress.replace(/[^0-9.:]/g, ''), // Basic IP sanitization\n        receivedAt: new Date().toISOString(),\n        processingId: `proc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      }\n    };\n    \n    results.push({\n      json: {\n        success: true,\n        validatedEvent: validatedEvent\n      }\n    });\n    \n  } catch (error) {\n    results.push({\n      json: {\n        success: false,\n        error: 'Event processing failed',\n        details: error.message,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "typeVersion": 2
    },    {
      "id": "pattern-analyzer",
      "name": "üîç Pattern Analyzer",
      "type": "n8n-nodes-base.code",
      "position": [680, 300],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Real-time Pattern Analysis\n// Analyzes incoming events for immediate insights and pattern detection\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  try {\n    if (!item.json.success) {\n      results.push(item);\n      continue;\n    }\n    \n    const { validatedEvent } = item.json;\n    const { eventType, userId, sessionId, data, timestamp } = validatedEvent;\n    \n    // Initialize analysis object\n    const analysis = {\n      eventType,\n      userId,\n      sessionId,\n      timestamp,\n      originalData: data,\n      insights: {},\n      patterns: [],\n      flags: []\n    };\n    \n    // Event-specific pattern analysis\n    switch (eventType) {\n      case 'VIDEO_WATCH':\n        analysis.insights = {\n          engagementScore: data.watchTime / (data.videoDuration || 1),\n          completionRate: data.completed ? 1 : (data.watchTime / (data.videoDuration || 1)),\n          skipPattern: data.watchTime < 30 ? 'early_exit' : 'normal',\n          repeatViewing: data.attempts > 1 ? true : false\n        };\n        \n        if (analysis.insights.engagementScore > 0.8) {\n          analysis.patterns.push('high_engagement');\n        } else if (analysis.insights.engagementScore < 0.3) {\n          analysis.patterns.push('low_engagement');\n          analysis.flags.push('potential_difficulty');\n        }\n        break;\n        \n      case 'CHAT_QUERY':\n        analysis.insights = {\n          queryLength: (data.query || '').length,\n          complexity: (data.query || '').split(' ').length > 10 ? 'complex' : 'simple',\n          topicCategory: data.topic || 'general',\n          satisfactionScore: data.satisfaction || 0\n        };\n        \n        if (analysis.insights.satisfactionScore < 3) {\n          analysis.flags.push('unsatisfied_query');\n        }\n        \n        if (analysis.insights.queryLength > 200) {\n          analysis.patterns.push('detailed_inquiry');\n        }\n        break;\n        \n      case 'TASK_COMPLETE':\n        analysis.insights = {\n          efficiencyScore: (data.expectedTime || data.timeSpent) / data.timeSpent,\n          difficultyMatch: data.difficulty === data.perceivedDifficulty,\n          successRate: data.success ? 1 : 0,\n          helpRequested: data.helpRequested || false\n        };\n        \n        if (analysis.insights.efficiencyScore > 1.5) {\n          analysis.patterns.push('fast_learner');\n        } else if (analysis.insights.efficiencyScore < 0.5) {\n          analysis.patterns.push('needs_support');\n          analysis.flags.push('difficulty_mismatch');\n        }\n        break;\n        \n      case 'HELP_REQUEST':\n        analysis.insights = {\n          helpFrequency: 'needs_calculation', // Will be calculated in aggregation\n          topicDifficulty: data.topic || 'unknown',\n          resolutionTime: data.resolutionTime || 0,\n          methodUsed: data.method || 'unknown'\n        };\n        \n        analysis.patterns.push('help_seeking');\n        if (data.resolutionTime > 300) { // 5 minutes\n          analysis.flags.push('complex_issue');\n        }\n        break;\n        \n      default:\n        analysis.insights = {\n          eventCategory: 'general_interaction',\n          dataPoints: Object.keys(data).length\n        };\n    }\n    \n    // Add temporal analysis\n    const eventHour = new Date(timestamp).getHours();\n    analysis.insights.timeOfDay = \n      eventHour < 6 ? 'late_night' :\n      eventHour < 12 ? 'morning' :\n      eventHour < 18 ? 'afternoon' : 'evening';\n    \n    // Session context analysis\n    analysis.insights.sessionContext = {\n      estimatedDuration: 'needs_calculation',\n      eventSequence: 'needs_session_data',\n      activityLevel: 'active' // Default for incoming events\n    };\n    \n    results.push({\n      json: {\n        success: true,\n        analysis: analysis,\n        originalEvent: validatedEvent\n      }\n    });\n    \n  } catch (error) {\n    results.push({\n      json: {\n        success: false,\n        error: 'Pattern analysis failed',\n        details: error.message,\n        timestamp: new Date().toISOString()\n      }\n    });\n  }\n}\n\nreturn results;"
      },
      "typeVersion": 2,
      "notes": "üîç INTELLIGENT PATTERN ANALYSIS ENGINE\n\nüìù Purpose: Real-time analysis of user interactions for behavioral insights\n\nüéØ Analysis Capabilities:\n‚Ä¢ Event-specific insight generation\n‚Ä¢ Pattern recognition (engagement, learning speed, help-seeking)\n‚Ä¢ Flag detection for issues (difficulty mismatches, low engagement)\n‚Ä¢ Temporal analysis (time-of-day patterns)\n‚Ä¢ Session context awareness\n\nüìä Event Type Analysis:\n‚Ä¢ VIDEO_WATCH: Engagement & completion patterns\n‚Ä¢ CHAT_QUERY: Query complexity & satisfaction\n‚Ä¢ TASK_COMPLETE: Efficiency & difficulty matching\n‚Ä¢ HELP_REQUEST: Support needs & resolution patterns\n\nüö® Automatic Flags:\n‚Ä¢ potential_difficulty: Low engagement detected\n‚Ä¢ unsatisfied_query: Poor chat satisfaction\n‚Ä¢ difficulty_mismatch: Task completion issues\n‚Ä¢ complex_issue: Extended help resolution time\n\n‚ö° Output: Enriched events with insights for downstream processing"
    },