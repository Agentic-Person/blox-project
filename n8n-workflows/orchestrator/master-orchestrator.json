{
  "name": "🎯 Master Orchestrator - Blox Wizard Enhanced System",
  "nodes": [
    {
      "parameters": {
        "path": "orchestrator",
        "httpMethod": "POST",
        "responseMode": "lastNode",
        "options": {}
      },
      "onError": "continueRegularOutput",
      "id": "webhook-main",
      "name": "🌐 Main Event Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [240, 300],
      "webhookId": "orchestrator-main",
      "notes": "🎯 MAIN EVENT ENTRY POINT\n\n• Receives ALL system events from external sources\n• POST requests with JSON payloads\n• Expected payload structure:\n  {\n    \"eventType\": \"chat_query|user_interaction|schedule_request|health_check\",\n    \"userId\": \"string\",\n    \"sessionId\": \"string\",\n    \"data\": { /* event-specific data */ },\n    \"timestamp\": \"ISO-8601\"\n  }\n\n🔒 Security: Add authentication in production\n📊 Monitoring: All events logged for analytics\n⚡ Performance: Responds immediately, processes async"
    },
    {
      "parameters": {},
      "id": "sticky-webhook-info",
      "name": "📋 Webhook Configuration Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, 140],
      "width": 400,
      "height": 120,
      "content": "🌐 WEBHOOK ENDPOINT CONFIGURATION\n\n• Path: /orchestrator\n• Method: POST only\n• Content-Type: application/json\n• Response: Returns workflow execution status\n\n⚠️ IMPORTANT: Configure proper authentication before production deployment!\n\n🔗 Full URL will be: https://your-n8n-domain.com/webhook/orchestrator"
    },
    {
      "parameters": {
        "mode": "rules",
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "id": "condition-chat-query",
                    "leftValue": "={{ $json.eventType }}",
                    "rightValue": "chat_query",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "🧠 Knowledge Engine"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "id": "condition-user-interaction",
                    "leftValue": "={{ $json.eventType }}",
                    "rightValue": "user_interaction",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "📊 Analytics Engine"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "id": "condition-schedule-request",
                    "leftValue": "={{ $json.eventType }}",
                    "rightValue": "schedule_request",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "📅 Scheduler Engine"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "id": "condition-health-check",
                    "leftValue": "={{ $json.eventType }}",
                    "rightValue": "health_check",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "🏥 Health Monitor"
            }
          ]
        },
        "options": {
          "fallbackOutput": "manual",
          "renameFallbackOutput": true,
          "fallbackOutputName": "❌ Unknown Event"
        }
      },
      "id": "switch-event-router",
      "name": "🔀 Event Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [520, 300],
      "notes": "🔀 INTELLIGENT EVENT ROUTING\n\n• Routes events to appropriate subsystems based on eventType\n• 4 main event types supported:\n  - chat_query → Knowledge Engine\n  - user_interaction → Analytics Engine  \n  - schedule_request → Scheduler Engine\n  - health_check → Health Monitor\n\n• Fallback output for unknown events\n• Case-sensitive matching for reliability\n• Each output labeled for clarity\n\n🔧 To add new event types:\n1. Add new condition in rules\n2. Create corresponding workflow\n3. Add Execute Workflow node\n\n⚡ Performance: Switch is very fast, minimal latency"
    },
    {
      "parameters": {},
      "id": "sticky-event-types",
      "name": "📝 Supported Event Types",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [520, 80],
      "width": 380,
      "height": 160,
      "content": "📋 SUPPORTED EVENT TYPES\n\n🧠 chat_query\n   • User asks question to AI tutor\n   • Requires semantic search through transcripts\n   • Returns answer with video timestamps\n\n📊 user_interaction\n   • Any user activity (clicks, views, completions)\n   • Feeds analytics and pattern recognition\n   • Updates learning recommendations\n\n📅 schedule_request\n   • Generate personalized daily tasks\n   • Triggered manually or by cron\n   • Uses analytics for adaptation\n\n🏥 health_check\n   • System status monitoring\n   • Performance metrics collection\n   • Error rate tracking"
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "{{ $workflow('knowledge-engine-semantic-search').id }}",
        "mode": "once"
      },
      "id": "execute-knowledge-engine",
      "name": "🧠 Execute Knowledge Engine",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [800, 160],
      "notes": "🧠 KNOWLEDGE ENGINE EXECUTION\n\n• Handles all chat queries and semantic search\n• Processes video transcript searches\n• Returns AI-generated answers with timestamps\n\n🔄 Workflow: 'knowledge-engine-semantic-search'\n• Input: { query, userId, sessionId }\n• Output: { answer, videoReferences, confidence }\n\n⚡ Performance: Typically 1-3 seconds response\n🎯 Accuracy: Uses vector embeddings for precision\n💾 Caching: Frequent queries cached in Redis\n\n🔧 Configuration:\n• Mode: 'once' - processes all items together\n• Source: 'database' - references saved workflow\n• Auto-retry on failure with exponential backoff"
    },
    {
      "parameters": {
        "source": "database", 
        "workflowId": "{{ $workflow('analytics-interaction-tracker').id }}",
        "mode": "once"
      },
      "id": "execute-analytics",
      "name": "📊 Execute Analytics Engine",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [800, 300],
      "notes": "📊 ANALYTICS ENGINE EXECUTION\n\n• Tracks all user interactions and behaviors\n• Feeds learning pattern analysis\n• Updates personalization algorithms\n\n🔄 Workflow: 'analytics-interaction-tracker'\n• Input: { eventType, userId, data, timestamp }\n• Output: { processed, insights, recommendations }\n\n📈 Analytics Types:\n• Video watch patterns\n• Chat query topics\n• Task completion rates\n• Help-seeking behaviors\n\n🔧 Configuration:\n• Real-time processing for immediate insights\n• Batch aggregation for daily reports\n• Feeds back to scheduler for adaptation"
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "{{ $workflow('scheduler-daily-generator').id }}",
        "mode": "once"
      },
      "id": "execute-scheduler",
      "name": "📅 Execute Scheduler Engine",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [800, 440],
      "notes": "📅 SCHEDULER ENGINE EXECUTION\n\n• Generates personalized daily learning tasks\n• Adapts based on user performance and preferences\n• Integrates with analytics for smart recommendations\n\n🔄 Workflow: 'scheduler-daily-generator'\n• Input: { userId, requestType, preferences }\n• Output: { tasks, schedule, adaptations }\n\n🎯 Personalization Factors:\n• Previous completion rates\n• Preferred learning times\n• Topic difficulty preferences\n• Recent chat query patterns\n\n⏰ Triggers:\n• Manual request via API\n• Daily cron job at midnight\n• Performance-based re-scheduling\n\n🔧 Smart Features:\n• Difficulty adaptation\n• Content variety balancing\n• Progress checkpoint integration"
    },
    {
      "parameters": {
        "source": "database",
        "workflowId": "{{ $workflow('health-monitor').id }}",
        "mode": "once"
      },
      "id": "execute-health-monitor",
      "name": "🏥 Execute Health Monitor",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [800, 580],
      "notes": "🏥 HEALTH MONITORING EXECUTION\n\n• System health checks and performance monitoring\n• Error rate tracking and alerting\n• Resource utilization monitoring\n\n🔄 Workflow: 'health-monitor'\n• Input: { checkType, timestamp }\n• Output: { status, metrics, alerts }\n\n📊 Monitored Metrics:\n• Workflow execution times\n• Error rates by subsystem\n• Database query performance\n• Redis cache hit rates\n• API response times\n\n🚨 Alerting:\n• Slack notifications for critical issues\n• Email alerts for performance degradation\n• Dashboard updates for real-time monitoring\n\n🔧 Health Checks:\n• Database connectivity\n• External API availability\n• Cache performance\n• Workflow execution status"
    },
    {
      "parameters": {
        "operation": "publish",
        "channel": "orchestrator_events",
        "messageData": "={{ JSON.stringify({\n  eventType: $json.eventType,\n  userId: $json.userId,\n  sessionId: $json.sessionId,\n  timestamp: $json.timestamp,\n  routedTo: $node[\"🔀 Event Router\"].outputIndex,\n  status: 'routed'\n}) }}"
      },
      "id": "redis-publish-event",
      "name": "📡 Publish Event to Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1080, 300],
      "onError": "continueRegularOutput",
      "notes": "📡 EVENT BROADCASTING\n\n• Publishes all routed events to Redis pub/sub\n• Enables real-time event streaming to other systems\n• Allows multiple subscribers to react to events\n\n🔗 Channel: 'orchestrator_events'\n📦 Message Format:\n{\n  eventType: string,\n  userId: string,\n  sessionId: string,\n  timestamp: ISO-8601,\n  routedTo: number (switch output index),\n  status: 'routed'\n}\n\n👥 Potential Subscribers:\n• Real-time dashboards\n• External analytics systems\n• Mobile app push notifications\n• Third-party integrations\n\n⚡ Performance: Redis pub/sub is extremely fast\n🔄 Reliability: Fire-and-forget, non-blocking\n📊 Monitoring: Track subscriber count and message volume\n\n🚨 Error Handling: Continues on Redis failure"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "session:{{ $json.sessionId }}:last_activity",
        "value": "={{ $json.timestamp }}",
        "options": {
          "expire": true,
          "ttl": 3600
        }
      },
      "id": "redis-update-session",
      "name": "🕐 Update Session Timestamp",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1080, 440],
      "onError": "continueRegularOutput",
      "notes": "🕐 SESSION STATE MANAGEMENT\n\n• Updates user session activity timestamp\n• Maintains session TTL of 1 hour (3600 seconds)\n• Enables session-based analytics and timeouts\n\n🔑 Key Pattern: 'session:{sessionId}:last_activity'\n💾 Value: ISO-8601 timestamp\n⏰ TTL: 3600 seconds (1 hour)\n\n📊 Use Cases:\n• Session timeout detection\n• User activity analytics\n• Concurrent session management\n• Performance optimization\n\n🔧 Configuration:\n• Auto-expire prevents Redis memory bloat\n• TTL refreshed on each activity\n• Consistent key naming pattern\n\n⚡ Performance: Redis SET is O(1) operation\n🔄 Reliability: Atomic operation with TTL\n🚨 Error Handling: Continues on Redis failure"
    },
    {
      "parameters": {
        "operation": "incr",
        "key": "stats:events:{{ $json.eventType }}",
        "options": {
          "expire": true,
          "ttl": 86400
        }
      },
      "id": "redis-increment-stats",
      "name": "📈 Increment Event Counter",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1080, 580],
      "onError": "continueRegularOutput",
      "notes": "📈 REAL-TIME STATISTICS\n\n• Increments event type counters for analytics\n• Daily TTL resets counters automatically\n• Enables real-time dashboard metrics\n\n🔑 Key Pattern: 'stats:events:{eventType}'\n🔢 Operation: Atomic increment (thread-safe)\n⏰ TTL: 86400 seconds (24 hours)\n\n📊 Tracked Metrics:\n• chat_query count per day\n• user_interaction volume\n• schedule_request frequency\n• health_check intervals\n\n🎯 Benefits:\n• Real-time system load monitoring\n• Usage pattern analysis\n• Capacity planning data\n• Performance trend tracking\n\n⚡ Performance: Redis INCR is O(1) and atomic\n🔄 Auto-reset: TTL ensures daily fresh counts\n📈 Analytics: Feed to dashboards and reports\n🚨 Error Handling: Continues on Redis failure"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  success: true,\n  orchestrator: 'master',\n  eventType: $json.eventType,\n  userId: $json.userId,\n  sessionId: $json.sessionId,\n  routedTo: $node[\"🔀 Event Router\"].outputName,\n  timestamp: $json.timestamp,\n  processingTime: (new Date().getTime() - new Date($json.timestamp).getTime()) + 'ms',\n  status: 'processed'\n} }}",
        "options": {}
      },
      "onError": "continueRegularOutput",
      "id": "respond-to-webhook",
      "name": "✅ Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1360, 300],
      "notes": "✅ SUCCESS RESPONSE HANDLER\n\n• Returns structured JSON response to webhook caller\n• Includes processing metadata and timing\n• Confirms successful event routing and execution\n\n📦 Response Structure:\n{\n  success: true,\n  orchestrator: 'master',\n  eventType: string,\n  userId: string,\n  sessionId: string,\n  routedTo: string (output name),\n  timestamp: ISO-8601,\n  processingTime: string (in milliseconds),\n  status: 'processed'\n}\n\n🎯 Response Benefits:\n• Client confirmation of successful processing\n• Performance timing for optimization\n• Routing information for debugging\n• Session tracking for analytics\n\n⚡ Processing Time Calculation:\n• Measures time from event timestamp to response\n• Helps identify performance bottlenecks\n• Enables SLA monitoring and optimization"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ {\n  success: false,\n  error: 'Unknown event type',\n  orchestrator: 'master',\n  eventType: $json.eventType || 'undefined',\n  userId: $json.userId || 'undefined',\n  timestamp: new Date().toISOString(),\n  supportedTypes: ['chat_query', 'user_interaction', 'schedule_request', 'health_check']\n} }}",
        "options": {}
      },
      "id": "respond-error-unknown",
      "name": "❌ Unknown Event Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [800, 720],
      "notes": "❌ UNKNOWN EVENT ERROR HANDLER\n\n• Handles events with unrecognized eventType\n• Returns helpful error message with supported types\n• Maintains system stability for invalid requests\n\n📦 Error Response Structure:\n{\n  success: false,\n  error: 'Unknown event type',\n  orchestrator: 'master',\n  eventType: string | 'undefined',\n  userId: string | 'undefined',\n  timestamp: ISO-8601,\n  supportedTypes: [array of valid event types]\n}\n\n🔧 Error Handling:\n• Graceful degradation for invalid events\n• Informative error messages for developers\n• Security: No sensitive information leaked\n• Logging: All errors logged for analysis\n\n📚 Supported Event Types Listed:\n• chat_query\n• user_interaction\n• schedule_request\n• health_check\n\n💡 Developer Guidance:\n• Clear error message\n• List of valid options\n• Proper HTTP status codes"
    },
    {
      "parameters": {},
      "id": "sticky-redis-info",
      "name": "🔧 Redis Configuration",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1080, 80],
      "width": 350,
      "height": 160,
      "content": "🔧 REDIS CONFIGURATION REQUIREMENTS\n\n📡 Pub/Sub Channel: 'orchestrator_events'\n• Subscribe to get real-time event stream\n• Perfect for dashboards and monitoring\n\n🕐 Session Keys: 'session:{sessionId}:last_activity'\n• TTL: 1 hour (3600 seconds)\n• Automatic cleanup prevents memory bloat\n\n📈 Stats Keys: 'stats:events:{eventType}'\n• TTL: 24 hours (86400 seconds)\n• Daily reset for fresh metrics\n\n⚠️ IMPORTANT: Configure Redis credentials in n8n settings!\n\n🔗 Redis Connection Required:\n• Host: your-redis-host\n• Port: 6379 (default)\n• Password: (if required)\n• Database: 0 (or specify)"
    },
    {
      "parameters": {},
      "id": "sticky-error-handling",
      "name": "🚨 Error Handling Strategy",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1360, 80],
      "width": 350,
      "height": 200,
      "content": "🚨 ERROR HANDLING & MONITORING\n\n⚡ Built-in Error Resilience:\n• Switch node handles unknown events gracefully\n• Execute Workflow nodes have auto-retry\n• Redis operations are atomic and safe\n\n🔄 Retry Strategy:\n• Failed workflow executions auto-retry 3x\n• Exponential backoff: 1s, 2s, 4s delays\n• Critical errors trigger alerts\n\n📊 Monitoring Integration:\n• All events published to Redis for tracking\n• Error rates tracked in real-time\n• Performance metrics collected automatically\n\n🚨 Alert Conditions:\n• High error rate (>5% in 5 minutes)\n• Slow response time (>10 seconds)\n• Workflow execution failures\n• Redis connection issues\n\n🔧 Production Checklist:\n□ Configure error webhooks\n□ Set up monitoring dashboard\n□ Test all error scenarios\n□ Configure backup Redis instance"
    },
    {
      "parameters": {},
      "id": "sticky-performance",
      "name": "⚡ Performance Optimization",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1360, 480],
      "width": 350,
      "height": 180,
      "content": "⚡ PERFORMANCE OPTIMIZATION NOTES\n\n🎯 Target Performance:\n• Webhook response: <500ms\n• Event routing: <100ms\n• Redis operations: <50ms\n• Total processing: <2 seconds\n\n🔧 Optimization Techniques:\n• Execute Workflow in 'once' mode for efficiency\n• Redis operations are non-blocking\n• Switch node is extremely fast\n• Minimal data transformation\n\n📊 Performance Monitoring:\n• Processing time included in responses\n• Redis stats track operation counts\n• Built-in timing for bottleneck identification\n\n🚀 Scaling Considerations:\n• Horizontal: Multiple n8n instances\n• Vertical: Increase Redis memory\n• Caching: Cache frequent workflow results\n• Load balancing: Distribute webhook load"
    }
  ],
  "pinData": {},
  "connections": {
    "🌐 Main Event Webhook": {
      "main": [
        [
          {
            "node": "🔀 Event Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔀 Event Router": {
      "main": [
        [
          {
            "node": "🧠 Execute Knowledge Engine",
            "type": "main",
            "index": 0
          },
          {
            "node": "📡 Publish Event to Redis",
            "type": "main",
            "index": 0
          },
          {
            "node": "🕐 Update Session Timestamp",
            "type": "main",
            "index": 0
          },
          {
            "node": "📈 Increment Event Counter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "📊 Execute Analytics Engine",
            "type": "main",
            "index": 0
          },
          {
            "node": "📡 Publish Event to Redis",
            "type": "main",
            "index": 0
          },
          {
            "node": "🕐 Update Session Timestamp",
            "type": "main",
            "index": 0
          },
          {
            "node": "📈 Increment Event Counter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "📅 Execute Scheduler Engine",
            "type": "main",
            "index": 0
          },
          {
            "node": "📡 Publish Event to Redis",
            "type": "main",
            "index": 0
          },
          {
            "node": "🕐 Update Session Timestamp",
            "type": "main",
            "index": 0
          },
          {
            "node": "📈 Increment Event Counter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "🏥 Execute Health Monitor",
            "type": "main",
            "index": 0
          },
          {
            "node": "📡 Publish Event to Redis",
            "type": "main",
            "index": 0
          },
          {
            "node": "🕐 Update Session Timestamp",
            "type": "main",
            "index": 0
          },
          {
            "node": "📈 Increment Event Counter",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "❌ Unknown Event Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🧠 Execute Knowledge Engine": {
      "main": [
        [
          {
            "node": "✅ Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📊 Execute Analytics Engine": {
      "main": [
        [
          {
            "node": "✅ Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📅 Execute Scheduler Engine": {
      "main": [
        [
          {
            "node": "✅ Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🏥 Execute Health Monitor": {
      "main": [
        [
          {
            "node": "✅ Success Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1.0.0",
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "blox-wizard-orchestrator"
  },
  "id": "master-orchestrator",
  "tags": [
    {
      "createdAt": "2024-01-01T00:00:00.000Z",
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "orchestrator",
      "name": "orchestrator"
    },
    {
      "createdAt": "2024-01-01T00:00:00.000Z", 
      "updatedAt": "2024-01-01T00:00:00.000Z",
      "id": "blox-wizard",
      "name": "blox-wizard"
    }
  ]
}