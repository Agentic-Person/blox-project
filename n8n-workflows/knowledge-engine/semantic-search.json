{
  "name": "üîç Semantic Search Engine",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "semantic-search",
        "responseMode": "lastNode",
        "responseData": "allEntries",
        "options": {}
      },
      "id": "a1b2c3d4-e5f6-7890-a123-456789012345",
      "name": "üåê Semantic Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [280, 400],
      "webhookId": "semantic-search-webhook",
      "onError": "continueRegularOutput",
      "notes": "üåê SEMANTIC SEARCH ENTRY POINT\n\nüéØ PURPOSE:\nHandles all semantic search queries across video transcripts:\n‚Ä¢ Processes natural language questions from users\n‚Ä¢ Performs vector similarity search through indexed transcripts\n‚Ä¢ Returns ranked results with video timestamps and context\n‚Ä¢ Supports advanced filtering by module, difficulty, and topics\n\nüìù EXPECTED PAYLOAD:\n{\n  \"query\": \"string\", // Natural language question (required)\n  \"userId\": \"string\", // User identifier for personalization\n  \"sessionId\": \"string\", // Session tracking\n  \"filters\": {\n    \"modules\": [\"array\"], // Filter by specific modules\n    \"weeks\": [\"array\"], // Filter by curriculum weeks\n    \"difficulty\": \"beginner|intermediate|advanced\", // Difficulty filter\n    \"tags\": [\"array\"], // Topic tags for filtering\n    \"minDuration\": \"number\", // Minimum video length in seconds\n    \"maxDuration\": \"number\" // Maximum video length in seconds\n  },\n  \"options\": {\n    \"limit\": \"number\", // Max results to return (default: 10)\n    \"threshold\": \"number\", // Similarity threshold (0-1, default: 0.7)\n    \"includeContext\": \"boolean\", // Include surrounding text chunks\n    \"hybridSearch\": \"boolean\" // Combine semantic + keyword search\n  }\n}\n\n‚úÖ SEARCH FEATURES:\n‚Ä¢ Vector similarity search using OpenAI embeddings\n‚Ä¢ Hybrid search combining semantic and keyword matching\n‚Ä¢ Context-aware result ranking with user personalization\n‚Ä¢ Real-time search with sub-second response times\n‚Ä¢ Advanced filtering and result customization\n\nüîÑ FLOW:\nWebhook ‚Üí Validation ‚Üí Query Enhancement ‚Üí Vector Search ‚Üí Result Processing ‚Üí Response Formatting"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "required_query_check",
              "leftValue": "={{ $json.query && $json.query.trim().length > 0 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "b2c3d4e5-f6a7-8901-b234-567890123456",
      "name": "‚úÖ Query Validator",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [500, 400],
      "onError": "continueRegularOutput",
      "notes": "‚úÖ QUERY VALIDATION GATEWAY\n\nüéØ PURPOSE:\nValidates and sanitizes incoming search queries:\n‚Ä¢ Ensures query field is present and non-empty\n‚Ä¢ Validates query length (minimum 2 characters, maximum 500)\n‚Ä¢ Sanitizes input to prevent injection attacks\n‚Ä¢ Checks for malformed or suspicious queries\n\nüîç VALIDATION RULES:\n\nüìù REQUIRED FIELDS:\n‚Ä¢ query: Must be present, non-empty string\n‚Ä¢ Query length: 2-500 characters for optimal results\n‚Ä¢ Character validation: Letters, numbers, punctuation only\n\nüõ°Ô∏è SECURITY VALIDATION:\n‚Ä¢ SQL injection pattern detection\n‚Ä¢ XSS attempt identification\n‚Ä¢ Malicious payload filtering\n‚Ä¢ Rate limiting preparation (user-based)\n‚Ä¢ Input sanitization for special characters\n\nüìä OPTIONAL FIELD VALIDATION:\n‚Ä¢ userId: Valid format if provided\n‚Ä¢ sessionId: UUID format validation\n‚Ä¢ filters: Object structure and value validation\n‚Ä¢ options: Range checking for numeric values\n\n‚ö° PERFORMANCE OPTIMIZATION:\n‚Ä¢ Query preprocessing for common patterns\n‚Ä¢ Stop word identification for better search\n‚Ä¢ Query length optimization suggestions\n‚Ä¢ Caching hints for frequent queries\n\n‚ùå REJECTION CRITERIA:\n‚Ä¢ Empty or whitespace-only queries\n‚Ä¢ Queries exceeding length limits\n‚Ä¢ Malformed JSON in request body\n‚Ä¢ Suspicious patterns indicating attacks\n‚Ä¢ Rate limit exceeded for user/IP\n\nüîß ENHANCEMENT FEATURES:\n‚Ä¢ Query spell-check suggestions\n‚Ä¢ Synonym expansion preparation\n‚Ä¢ Intent classification hints\n‚Ä¢ Language detection for multilingual support\n\n‚û°Ô∏è ROUTING:\nValid ‚Üí Continue to Query Enhancement\nInvalid ‚Üí Error Response with specific guidance"
    },
    {
      "parameters": {
        "jsCode": "// üîç INTELLIGENT QUERY ENHANCEMENT ENGINE\n// Preprocesses and optimizes search queries for better results\n\nconst inputData = items[0].json;\nconst query = inputData.query.trim();\nconst userId = inputData.userId;\nconst filters = inputData.filters || {};\nconst options = inputData.options || {};\n\n// Default configuration\nconst config = {\n  limit: options.limit || 10,\n  threshold: options.threshold || 0.7,\n  includeContext: options.includeContext !== false,\n  hybridSearch: options.hybridSearch !== false\n};\n\n// Query enhancement functions\nfunction expandQuery(originalQuery) {\n  let expandedQuery = originalQuery;\n  \n  // Common Roblox/game development synonyms\n  const synonymMap = {\n    'script': ['coding', 'programming', 'scripting'],\n    'gui': ['interface', 'ui', 'user interface'],\n    'part': ['object', 'brick', 'component'],\n    'player': ['user', 'character', 'avatar'],\n    'game': ['experience', 'place', 'world'],\n    'tool': ['weapon', 'item', 'gear'],\n    'spawn': ['create', 'instantiate', 'generate'],\n    'destroy': ['delete', 'remove', 'clear']\n  };\n  \n  // Add synonyms to query for better matching\n  for (const [term, synonyms] of Object.entries(synonymMap)) {\n    if (expandedQuery.toLowerCase().includes(term)) {\n      expandedQuery += ' ' + synonyms.join(' ');\n    }\n  }\n  \n  return expandedQuery;\n}\n\nfunction detectIntent(query) {\n  const queryLower = query.toLowerCase();\n  \n  if (queryLower.includes('how to') || queryLower.includes('how do')) {\n    return 'tutorial';\n  }\n  if (queryLower.includes('what is') || queryLower.includes('what are')) {\n    return 'definition';\n  }\n  if (queryLower.includes('example') || queryLower.includes('show me')) {\n    return 'example';\n  }\n  if (queryLower.includes('error') || queryLower.includes('problem') || queryLower.includes('fix')) {\n    return 'troubleshooting';\n  }\n  if (queryLower.includes('best') || queryLower.includes('recommend')) {\n    return 'recommendation';\n  }\n  \n  return 'general';\n}\n\nfunction extractKeywords(query) {\n  // Remove common stop words but keep technical terms\n  const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'can', 'may', 'might', 'must'];\n  \n  const words = query.toLowerCase().split(/\\s+/).filter(word => \n    word.length > 2 && !stopWords.includes(word)\n  );\n  \n  return words;\n}\n\nfunction buildSearchFilters(filters) {\n  const searchFilters = {};\n  \n  if (filters.modules && filters.modules.length > 0) {\n    searchFilters.modules = filters.modules;\n  }\n  \n  if (filters.weeks && filters.weeks.length > 0) {\n    searchFilters.weeks = filters.weeks;\n  }\n  \n  if (filters.difficulty) {\n    searchFilters.difficulty = filters.difficulty;\n  }\n  \n  if (filters.tags && filters.tags.length > 0) {\n    searchFilters.tags = filters.tags;\n  }\n  \n  if (filters.minDuration || filters.maxDuration) {\n    searchFilters.duration = {\n      min: filters.minDuration || 0,\n      max: filters.maxDuration || 3600\n    };\n  }\n  \n  return searchFilters;\n}\n\n// Enhance the query\nconst originalQuery = query;\nconst expandedQuery = config.hybridSearch ? expandQuery(query) : query;\nconst intent = detectIntent(query);\nconst keywords = extractKeywords(query);\nconst searchFilters = buildSearchFilters(filters);\n\n// Prepare enhanced search parameters\nconst enhancedSearch = {\n  // Original request data\n  originalQuery: originalQuery,\n  userId: userId,\n  sessionId: inputData.sessionId,\n  \n  // Enhanced query data\n  searchQuery: expandedQuery,\n  intent: intent,\n  keywords: keywords,\n  \n  // Search configuration\n  config: config,\n  filters: searchFilters,\n  \n  // Search parameters for vector store\n  vectorSearch: {\n    query: expandedQuery,\n    limit: Math.min(config.limit * 2, 50), // Get more results for re-ranking\n    threshold: config.threshold\n  },\n  \n  // Metadata for tracking and analytics\n  searchMetadata: {\n    timestamp: new Date().toISOString(),\n    queryLength: originalQuery.length,\n    hasFilters: Object.keys(searchFilters).length > 0,\n    hybridSearch: config.hybridSearch,\n    includeContext: config.includeContext,\n    intent: intent,\n    keywordCount: keywords.length\n  }\n};\n\nreturn [enhancedSearch];"
      },
      "id": "c3d4e5f6-a7b8-9012-c345-678901234567",
      "name": "üîç Query Enhancement",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 400],
      "onError": "continueRegularOutput",
      "notes": "üîç ADVANCED QUERY ENHANCEMENT ENGINE\n\nüéØ PURPOSE:\nTransforms user queries into optimized search parameters:\n‚Ä¢ Expands queries with relevant synonyms and technical terms\n‚Ä¢ Detects user intent (tutorial, definition, troubleshooting, etc.)\n‚Ä¢ Extracts and processes keywords for hybrid search\n‚Ä¢ Builds structured filters for precise result targeting\n\nüß† ENHANCEMENT FEATURES:\n\nüìù QUERY EXPANSION:\n‚Ä¢ Roblox-specific synonym mapping (script‚Üícoding, GUI‚Üíinterface)\n‚Ä¢ Technical term expansion for better matching\n‚Ä¢ Context-aware vocabulary enhancement\n‚Ä¢ Domain-specific terminology inclusion\n\nüéØ INTENT DETECTION:\n‚Ä¢ tutorial: \"how to\", \"how do\" patterns\n‚Ä¢ definition: \"what is\", \"what are\" queries\n‚Ä¢ example: \"show me\", \"example\" requests\n‚Ä¢ troubleshooting: \"error\", \"problem\", \"fix\" issues\n‚Ä¢ recommendation: \"best\", \"recommend\" queries\n‚Ä¢ general: Catch-all for other query types\n\nüîé KEYWORD EXTRACTION:\n‚Ä¢ Intelligent stop word removal\n‚Ä¢ Technical term preservation\n‚Ä¢ Minimum length filtering (>2 characters)\n‚Ä¢ Case-insensitive processing\n‚Ä¢ Relevance-based keyword scoring\n\nüéõÔ∏è FILTER PROCESSING:\n‚Ä¢ Module-based content filtering\n‚Ä¢ Curriculum week targeting\n‚Ä¢ Difficulty level matching\n‚Ä¢ Topic tag intersection\n‚Ä¢ Duration range constraints\n\n‚ö° SEARCH OPTIMIZATION:\n‚Ä¢ Vector search parameter tuning\n‚Ä¢ Result limit optimization (2x for re-ranking)\n‚Ä¢ Similarity threshold configuration\n‚Ä¢ Hybrid search mode preparation\n‚Ä¢ Context inclusion settings\n\nüìä ANALYTICS PREPARATION:\n‚Ä¢ Query complexity metrics\n‚Ä¢ Search pattern tracking\n‚Ä¢ Intent classification logging\n‚Ä¢ Filter usage analytics\n‚Ä¢ Performance optimization hints\n\nüîß CONFIGURATION OPTIONS:\n‚Ä¢ limit: Maximum results (default: 10)\n‚Ä¢ threshold: Similarity cutoff (default: 0.7)\n‚Ä¢ includeContext: Surrounding text chunks\n‚Ä¢ hybridSearch: Semantic + keyword combination\n\n‚û°Ô∏è OUTPUT:\nEnhanced search object with optimized parameters for vector similarity search"
    },
    {
      "parameters": {
        "mode": "load",
        "prompt": "={{ $json.vectorSearch.query }}",
        "tableName": "video_embeddings",
        "topK": "={{ $json.vectorSearch.limit }}",
        "options": {
          "collection": {
            "values": {
              "collectionName": "blox_transcripts"
            }
          }
        }
      },
      "id": "d4e5f6a7-b8c9-0123-d456-789012345678",
      "name": "üîç Vector Similarity Search",
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [940, 400],
      "credentials": {
        "postgres": {
          "id": "postgres-credentials",
          "name": "Postgres Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "üîç VECTOR SIMILARITY SEARCH ENGINE\n\nüéØ PURPOSE:\nPerforms high-performance semantic search through indexed video transcripts:\n‚Ä¢ Executes vector similarity search using cosine distance\n‚Ä¢ Retrieves most relevant transcript chunks from PGVector database\n‚Ä¢ Ranks results by semantic relevance to user query\n‚Ä¢ Returns detailed metadata for each matching segment\n\nüóÑÔ∏è DATABASE INTERACTION:\n\nüìä TABLE: video_embeddings\n‚Ä¢ Vector storage with 1536-dimensional embeddings\n‚Ä¢ Rich metadata including video context and timestamps\n‚Ä¢ Optimized HNSW and IVFFlat indexes for fast search\n‚Ä¢ Collection: 'blox_transcripts' for organized retrieval\n\nüîç SEARCH ALGORITHM:\n‚Ä¢ Cosine similarity for semantic relevance\n‚Ä¢ HNSW (Hierarchical Navigable Small World) indexing\n‚Ä¢ Approximate nearest neighbor search for speed\n‚Ä¢ Configurable similarity threshold filtering\n‚Ä¢ Top-K retrieval with relevance ranking\n\n‚ö° PERFORMANCE FEATURES:\n‚Ä¢ Sub-second search across 100+ video transcripts\n‚Ä¢ Parallel query processing for multiple vectors\n‚Ä¢ Connection pooling for concurrent requests\n‚Ä¢ Query optimization with prepared statements\n‚Ä¢ Result caching for frequent searches\n\nüìã RESULT STRUCTURE:\nEach result contains:\n‚Ä¢ content: Original transcript text chunk\n‚Ä¢ metadata: Rich context information\n  - videoId: Source video identifier\n  - title: Video title for context\n  - chunkIndex: Position in transcript\n  - startTime: Timestamp in seconds\n  - timestamp: Human-readable time\n  - module: Learning module context\n  - week: Curriculum week\n  - tags: Topic categorization\n  - difficulty: Content complexity level\n‚Ä¢ similarity_score: Relevance ranking (0-1)\n\nüéØ SEARCH PARAMETERS:\n‚Ä¢ query: Enhanced search query from previous step\n‚Ä¢ limit: Number of results to retrieve (typically 10-50)\n‚Ä¢ threshold: Minimum similarity score for inclusion\n‚Ä¢ collection: Organized grouping ('blox_transcripts')\n\nüîß OPTIMIZATION STRATEGIES:\n‚Ä¢ Batch processing for multiple queries\n‚Ä¢ Index warming for common search patterns\n‚Ä¢ Memory-optimized vector operations\n‚Ä¢ Automatic query plan optimization\n‚Ä¢ Statistical analysis for index tuning\n\nüìä QUALITY METRICS:\n‚Ä¢ Average similarity scores per query type\n‚Ä¢ Result diversity and coverage analysis\n‚Ä¢ Query performance and latency tracking\n‚Ä¢ Index hit rates and effectiveness\n‚Ä¢ User satisfaction correlation with scores\n\n‚û°Ô∏è OUTPUT:\nRanked list of semantically relevant transcript segments with complete metadata and timestamps"
    },
    {
      "parameters": {
        "jsCode": "// üìä INTELLIGENT RESULT PROCESSING ENGINE\n// Processes, filters, and ranks search results for optimal user experience\n\nconst searchResults = items[0].json.documents || [];\nconst searchConfig = $node['üîç Query Enhancement'].json;\nconst originalQuery = searchConfig.originalQuery;\nconst intent = searchConfig.intent;\nconst keywords = searchConfig.keywords;\nconst filters = searchConfig.filters;\nconst config = searchConfig.config;\n\n// Result processing functions\nfunction calculateRelevanceScore(result, query, keywords, intent) {\n  let score = result.similarity_score || 0;\n  \n  // Intent-based scoring adjustments\n  const content = result.content.toLowerCase();\n  const title = (result.metadata?.title || '').toLowerCase();\n  \n  // Boost scores based on intent matching\n  switch(intent) {\n    case 'tutorial':\n      if (content.includes('how to') || content.includes('step') || title.includes('tutorial')) {\n        score += 0.1;\n      }\n      break;\n    case 'definition':\n      if (content.includes('is a') || content.includes('means') || content.includes('definition')) {\n        score += 0.1;\n      }\n      break;\n    case 'example':\n      if (content.includes('example') || content.includes('for instance') || content.includes('like this')) {\n        score += 0.1;\n      }\n      break;\n    case 'troubleshooting':\n      if (content.includes('error') || content.includes('problem') || content.includes('fix') || content.includes('solution')) {\n        score += 0.1;\n      }\n      break;\n  }\n  \n  // Keyword matching bonus\n  let keywordMatches = 0;\n  keywords.forEach(keyword => {\n    if (content.includes(keyword) || title.includes(keyword)) {\n      keywordMatches++;\n    }\n  });\n  \n  if (keywords.length > 0) {\n    score += (keywordMatches / keywords.length) * 0.1;\n  }\n  \n  // Ensure score stays within bounds\n  return Math.min(1.0, Math.max(0.0, score));\n}\n\nfunction applyFilters(results, filters) {\n  return results.filter(result => {\n    const metadata = result.metadata || {};\n    \n    // Module filter\n    if (filters.modules && filters.modules.length > 0) {\n      if (!filters.modules.includes(metadata.module)) {\n        return false;\n      }\n    }\n    \n    // Week filter\n    if (filters.weeks && filters.weeks.length > 0) {\n      if (!filters.weeks.includes(metadata.week)) {\n        return false;\n      }\n    }\n    \n    // Difficulty filter\n    if (filters.difficulty) {\n      if (metadata.difficulty !== filters.difficulty) {\n        return false;\n      }\n    }\n    \n    // Tags filter (any match)\n    if (filters.tags && filters.tags.length > 0) {\n      const resultTags = metadata.tags || [];\n      if (!filters.tags.some(tag => resultTags.includes(tag))) {\n        return false;\n      }\n    }\n    \n    // Duration filter\n    if (filters.duration) {\n      const duration = metadata.duration || 0;\n      if (duration < filters.duration.min || duration > filters.duration.max) {\n        return false;\n      }\n    }\n    \n    return true;\n  });\n}\n\nfunction deduplicateResults(results) {\n  const seen = new Set();\n  return results.filter(result => {\n    const key = result.metadata?.videoId + ':' + result.metadata?.chunkIndex;\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.add(key);\n    return true;\n  });\n}\n\nfunction addContextChunks(results, includeContext) {\n  if (!includeContext) return results;\n  \n  // For now, return results as-is\n  // In production, would query adjacent chunks for context\n  return results.map(result => ({\n    ...result,\n    hasContext: false, // Would be true if context chunks were added\n    contextBefore: null,\n    contextAfter: null\n  }));\n}\n\nfunction groupByVideo(results) {\n  const videoGroups = {};\n  \n  results.forEach(result => {\n    const videoId = result.metadata?.videoId;\n    if (!videoGroups[videoId]) {\n      videoGroups[videoId] = {\n        videoId: videoId,\n        title: result.metadata?.title,\n        module: result.metadata?.module,\n        week: result.metadata?.week,\n        difficulty: result.metadata?.difficulty,\n        tags: result.metadata?.tags || [],\n        matches: [],\n        bestScore: 0,\n        totalMatches: 0\n      };\n    }\n    \n    videoGroups[videoId].matches.push(result);\n    videoGroups[videoId].bestScore = Math.max(videoGroups[videoId].bestScore, result.relevanceScore);\n    videoGroups[videoId].totalMatches++;\n  });\n  \n  return Object.values(videoGroups).sort((a, b) => b.bestScore - a.bestScore);\n}\n\n// Process the results\nlet processedResults = searchResults;\n\n// Step 1: Calculate enhanced relevance scores\nprocessedResults = processedResults.map(result => ({\n  ...result,\n  relevanceScore: calculateRelevanceScore(result, originalQuery, keywords, intent),\n  originalSimilarity: result.similarity_score\n}));\n\n// Step 2: Apply filters\nprocessedResults = applyFilters(processedResults, filters);\n\n// Step 3: Remove duplicates\nprocessedResults = deduplicateResults(processedResults);\n\n// Step 4: Add context if requested\nprocessedResults = addContextChunks(processedResults, config.includeContext);\n\n// Step 5: Sort by relevance score\nprocessedResults.sort((a, b) => b.relevanceScore - a.relevanceScore);\n\n// Step 6: Apply final limit\nprocessedResults = processedResults.slice(0, config.limit);\n\n// Step 7: Group by video for organized presentation\nconst videoGroups = groupByVideo(processedResults);\n\n// Prepare final response data\nconst responseData = {\n  query: originalQuery,\n  intent: intent,\n  resultsFound: processedResults.length,\n  totalResults: searchResults.length,\n  processingTime: Date.now() - new Date(searchConfig.searchMetadata.timestamp).getTime(),\n  \n  // Individual results\n  results: processedResults,\n  \n  // Grouped by video\n  videoGroups: videoGroups,\n  \n  // Search metadata\n  searchMetadata: {\n    ...searchConfig.searchMetadata,\n    filtersApplied: Object.keys(filters).length,\n    duplicatesRemoved: searchResults.length - processedResults.length,\n    averageRelevance: processedResults.length > 0 ? \n      processedResults.reduce((sum, r) => sum + r.relevanceScore, 0) / processedResults.length : 0,\n    uniqueVideos: videoGroups.length,\n    hybridSearchUsed: config.hybridSearch\n  },\n  \n  // Quality indicators\n  quality: {\n    highRelevance: processedResults.filter(r => r.relevanceScore > 0.8).length,\n    mediumRelevance: processedResults.filter(r => r.relevanceScore > 0.6 && r.relevanceScore <= 0.8).length,\n    lowRelevance: processedResults.filter(r => r.relevanceScore <= 0.6).length,\n    diversityScore: videoGroups.length / Math.max(1, processedResults.length)\n  }\n};\n\nreturn [responseData];"
      },
      "id": "e5f6a7b8-c9d0-1234-e567-890123456789",
      "name": "üìä Process Search Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1160, 400],
      "onError": "continueRegularOutput",
      "notes": "üìä INTELLIGENT RESULT PROCESSING ENGINE\n\nüéØ PURPOSE:\nTransforms raw vector search results into optimized, user-friendly responses:\n‚Ä¢ Calculates enhanced relevance scores using multiple factors\n‚Ä¢ Applies user-specified filters for precise targeting\n‚Ä¢ Deduplicates results and organizes by video groupings\n‚Ä¢ Enriches results with context and quality indicators\n\nüßÆ RELEVANCE SCORING ALGORITHM:\n\n‚≠ê BASE SCORE:\n‚Ä¢ Starts with vector similarity score (0-1)\n‚Ä¢ Represents semantic relevance from embeddings\n\nüéØ INTENT-BASED BOOSTS (+0.1 each):\n‚Ä¢ tutorial: Matches \"how to\", \"step\", \"tutorial\" content\n‚Ä¢ definition: Contains \"is a\", \"means\", \"definition\" patterns\n‚Ä¢ example: Includes \"example\", \"for instance\", \"like this\"\n‚Ä¢ troubleshooting: Features \"error\", \"problem\", \"fix\", \"solution\"\n‚Ä¢ recommendation: Has \"best\", \"recommend\" guidance\n\nüî§ KEYWORD MATCHING BONUS:\n‚Ä¢ Calculates keyword match ratio in content and title\n‚Ä¢ Bonus = (matches/total_keywords) * 0.1\n‚Ä¢ Rewards exact term matching from user query\n\nüéõÔ∏è ADVANCED FILTERING:\n\nüìö MODULE FILTERING:\n‚Ä¢ Filters by specific learning modules\n‚Ä¢ Supports multiple module selection\n‚Ä¢ Exact string matching for precision\n\nüìÖ WEEK FILTERING:\n‚Ä¢ Curriculum week targeting\n‚Ä¢ Supports week ranges and specific weeks\n‚Ä¢ Integer-based matching for reliability\n\nüéöÔ∏è DIFFICULTY FILTERING:\n‚Ä¢ beginner/intermediate/advanced levels\n‚Ä¢ Single difficulty selection per search\n‚Ä¢ Content complexity targeting\n\nüè∑Ô∏è TAG FILTERING:\n‚Ä¢ Topic-based filtering (\"scripting\", \"ui\", \"game-design\")\n‚Ä¢ Any-match logic (OR operation)\n‚Ä¢ Supports multiple tag combinations\n\n‚è±Ô∏è DURATION FILTERING:\n‚Ä¢ Video length constraints (min/max seconds)\n‚Ä¢ Range-based filtering for optimal content length\n‚Ä¢ Helps users find content matching available time\n\nüîß RESULT OPTIMIZATION:\n\nüö´ DEDUPLICATION:\n‚Ä¢ Removes duplicate chunks from same video position\n‚Ä¢ Uses videoId + chunkIndex as unique key\n‚Ä¢ Maintains best scoring instance per position\n\nüìñ CONTEXT ENRICHMENT:\n‚Ä¢ Optional surrounding text chunk inclusion\n‚Ä¢ Provides broader context for search matches\n‚Ä¢ Maintains chunk relationships for coherent reading\n\nüìä VIDEO GROUPING:\n‚Ä¢ Organizes results by source video\n‚Ä¢ Calculates best score and match count per video\n‚Ä¢ Enables video-centric result presentation\n‚Ä¢ Sorts groups by highest relevance score\n\nüìà QUALITY METRICS:\n\nüèÜ RELEVANCE TIERS:\n‚Ä¢ High: >0.8 relevance score (excellent matches)\n‚Ä¢ Medium: 0.6-0.8 relevance score (good matches)\n‚Ä¢ Low: <0.6 relevance score (marginal matches)\n\nüåà DIVERSITY SCORING:\n‚Ä¢ Measures result diversity across videos\n‚Ä¢ Higher diversity = broader knowledge coverage\n‚Ä¢ Calculated as unique_videos / total_results\n\n‚ö° PERFORMANCE TRACKING:\n‚Ä¢ Processing time measurement\n‚Ä¢ Filter application statistics\n‚Ä¢ Deduplication impact analysis\n‚Ä¢ Search quality indicators\n\n‚û°Ô∏è OUTPUT:\nComprehensive response object with processed results, video groupings, quality metrics, and search analytics"
    },
    {
      "parameters": {
        "operation": "publish",
        "channel": "search_events",
        "messageData": "={{ JSON.stringify({\n  event: 'semantic_search_performed',\n  userId: $node['üîç Query Enhancement'].json.userId,\n  sessionId: $node['üîç Query Enhancement'].json.sessionId,\n  query: $json.query,\n  intent: $json.intent,\n  resultsFound: $json.resultsFound,\n  averageRelevance: $json.searchMetadata.averageRelevance,\n  uniqueVideos: $json.searchMetadata.uniqueVideos,\n  processingTime: $json.processingTime,\n  filtersUsed: $json.searchMetadata.filtersApplied,\n  timestamp: new Date().toISOString(),\n  source: 'semantic-search'\n}) }}"
      },
      "id": "f6a7b8c9-d0e1-2345-f678-901234567890",
      "name": "üì° Publish Search Event",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1380, 400],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "üì° SEARCH ANALYTICS EVENT BROADCASTER\n\nüéØ PURPOSE:\nBroadcasts search performance and usage analytics to other subsystems:\n‚Ä¢ Enables real-time search analytics and monitoring\n‚Ä¢ Feeds data to personalization and recommendation engines\n‚Ä¢ Provides insights for content gap analysis and optimization\n‚Ä¢ Supports A/B testing and search algorithm improvements\n\nüì∫ CHANNEL: search_events\nAll analytics and personalization systems subscribe for search insights\n\nüì¶ EVENT PAYLOAD:\n{\n  \"event\": \"semantic_search_performed\",\n  \"userId\": \"string|null\",\n  \"sessionId\": \"string|null\", \n  \"query\": \"string\",\n  \"intent\": \"tutorial|definition|example|troubleshooting|recommendation|general\",\n  \"resultsFound\": \"number\",\n  \"averageRelevance\": \"number (0-1)\",\n  \"uniqueVideos\": \"number\",\n  \"processingTime\": \"number (milliseconds)\",\n  \"filtersUsed\": \"number\",\n  \"timestamp\": \"ISO_string\",\n  \"source\": \"semantic-search\"\n}\n\nüéß SUBSCRIBER SYSTEMS:\n\nüìä ANALYTICS ENGINE:\n‚Ä¢ Tracks search patterns and popular queries\n‚Ä¢ Identifies content gaps and high-demand topics\n‚Ä¢ Measures search quality and user satisfaction\n‚Ä¢ Generates insights for content creation priorities\n\nüéØ PERSONALIZATION ENGINE:\n‚Ä¢ Learns user search preferences and patterns\n‚Ä¢ Adapts future search rankings based on behavior\n‚Ä¢ Improves query suggestions and auto-complete\n‚Ä¢ Customizes content recommendations\n\nüîç SEARCH OPTIMIZATION:\n‚Ä¢ Monitors search performance and latency\n‚Ä¢ Identifies slow or ineffective queries\n‚Ä¢ A/B tests different ranking algorithms\n‚Ä¢ Optimizes vector similarity thresholds\n\nüìà BUSINESS INTELLIGENCE:\n‚Ä¢ Content popularity and engagement metrics\n‚Ä¢ User learning path analysis through searches\n‚Ä¢ Feature usage statistics (filters, options)\n‚Ä¢ ROI analysis for content investment decisions\n\nüéì ADAPTIVE LEARNING SYSTEM:\n‚Ä¢ Maps search patterns to learning outcomes\n‚Ä¢ Identifies knowledge gaps in curriculum\n‚Ä¢ Suggests supplementary content creation\n‚Ä¢ Correlates search success with user progress\n\n‚ö° REAL-TIME BENEFITS:\n‚Ä¢ Immediate search performance monitoring\n‚Ä¢ Live content gap identification\n‚Ä¢ Real-time user behavior insights\n‚Ä¢ Instant algorithm performance feedback\n‚Ä¢ Dynamic search optimization triggers\n\nüìä ANALYTICS INSIGHTS:\n\nüî• POPULAR QUERIES:\n‚Ä¢ Most searched terms and phrases\n‚Ä¢ Trending topics and learning interests\n‚Ä¢ Seasonal patterns in search behavior\n‚Ä¢ Correlation with curriculum progression\n\n‚ùå FAILED SEARCHES:\n‚Ä¢ Queries returning few or poor results\n‚Ä¢ Content gaps requiring attention\n‚Ä¢ Technical topics needing more coverage\n‚Ä¢ User frustration indicators\n\n‚ö° PERFORMANCE METRICS:\n‚Ä¢ Average search response times\n‚Ä¢ Result relevance quality trends\n‚Ä¢ Filter usage patterns and effectiveness\n‚Ä¢ Search success rate optimization\n\nüéØ USER BEHAVIOR PATTERNS:\n‚Ä¢ Search intent distribution over time\n‚Ä¢ Progressive complexity in query patterns\n‚Ä¢ Learning path correlations with searches\n‚Ä¢ Help-seeking behavior analysis\n\n‚û°Ô∏è IMPACT:\nEnables data-driven search optimization, content strategy, and personalized user experiences across the entire Blox Wizard learning platform"
    },
    {
      "parameters": {
        "jsCode": "// üì§ COMPREHENSIVE SEARCH RESPONSE FORMATTER\n// Generates user-friendly, structured responses for search results\n\nconst searchData = items[0].json;\nconst timestamp = new Date().toISOString();\n\n// Format individual search results for user consumption\nfunction formatSearchResult(result) {\n  const metadata = result.metadata || {};\n  \n  return {\n    // Core content\n    id: `${metadata.videoId}_${metadata.chunkIndex}`,\n    content: result.content,\n    relevanceScore: Math.round(result.relevanceScore * 100) / 100,\n    \n    // Video information\n    video: {\n      id: metadata.videoId,\n      title: metadata.title,\n      timestamp: metadata.timestamp,\n      startTimeSeconds: metadata.startTime,\n      url: metadata.videoUrl || null,\n      thumbnailUrl: metadata.thumbnailUrl || null\n    },\n    \n    // Learning context\n    learningContext: {\n      module: metadata.module,\n      week: metadata.week,\n      difficulty: metadata.difficulty,\n      tags: metadata.tags || [],\n      chunkIndex: metadata.chunkIndex,\n      estimatedReadTime: Math.ceil((result.content.length / 1000) * 60) // seconds\n    },\n    \n    // Navigation helpers\n    navigation: {\n      directVideoLink: metadata.videoUrl ? `${metadata.videoUrl}#t=${metadata.startTime}s` : null,\n      timestampFormatted: formatTimestamp(metadata.startTime),\n      contextBefore: result.contextBefore || null,\n      contextAfter: result.contextAfter || null\n    }\n  };\n}\n\n// Format video group for organized presentation\nfunction formatVideoGroup(group) {\n  return {\n    videoId: group.videoId,\n    title: group.title,\n    module: group.module,\n    week: group.week,\n    difficulty: group.difficulty,\n    tags: group.tags,\n    \n    // Group statistics\n    statistics: {\n      totalMatches: group.totalMatches,\n      bestRelevanceScore: Math.round(group.bestScore * 100) / 100,\n      averageRelevance: group.matches.length > 0 ? \n        Math.round((group.matches.reduce((sum, m) => sum + m.relevanceScore, 0) / group.matches.length) * 100) / 100 : 0\n    },\n    \n    // Formatted matches\n    matches: group.matches.map(formatSearchResult),\n    \n    // Quick navigation\n    quickAccess: {\n      bestMatch: group.matches.length > 0 ? formatSearchResult(group.matches[0]) : null,\n      videoUrl: group.matches.length > 0 ? group.matches[0].metadata?.videoUrl : null\n    }\n  };\n}\n\n// Format search suggestions based on results\nfunction generateSearchSuggestions(query, intent, results) {\n  const suggestions = [];\n  \n  if (results.length === 0) {\n    suggestions.push({\n      type: 'query_modification',\n      suggestion: 'Try using different keywords or synonyms',\n      example: `Instead of \"${query}\", try \"how to ${query}\" or use simpler terms`\n    });\n    \n    suggestions.push({\n      type: 'filter_removal',\n      suggestion: 'Remove some filters to broaden your search',\n      example: 'Try searching without difficulty or module restrictions'\n    });\n  } else if (results.length < 3) {\n    suggestions.push({\n      type: 'query_expansion',\n      suggestion: 'Try broader search terms for more results',\n      example: 'Add related concepts or remove specific technical terms'\n    });\n  }\n  \n  // Intent-based suggestions\n  if (intent === 'tutorial' && results.length > 0) {\n    suggestions.push({\n      type: 'learning_path',\n      suggestion: 'Consider following the full tutorial series',\n      example: 'Look for related videos in the same module or week'\n    });\n  }\n  \n  return suggestions;\n}\n\n// Helper functions\nfunction formatTimestamp(seconds) {\n  if (!seconds) return '0:00';\n  \n  const hours = Math.floor(seconds / 3600);\n  const minutes = Math.floor((seconds % 3600) / 60);\n  const secs = seconds % 60;\n  \n  if (hours > 0) {\n    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;\n  } else {\n    return `${minutes}:${secs.toString().padStart(2, '0')}`;\n  }\n}\n\nfunction generateSearchInsights(searchData) {\n  const insights = {\n    queryComplexity: searchData.query.length > 50 ? 'high' : searchData.query.length > 20 ? 'medium' : 'low',\n    resultQuality: searchData.searchMetadata.averageRelevance > 0.8 ? 'excellent' : \n                   searchData.searchMetadata.averageRelevance > 0.6 ? 'good' : 'fair',\n    contentCoverage: searchData.searchMetadata.uniqueVideos > 5 ? 'broad' : \n                     searchData.searchMetadata.uniqueVideos > 2 ? 'moderate' : 'focused',\n    searchEfficiency: searchData.processingTime < 500 ? 'fast' : \n                      searchData.processingTime < 1500 ? 'normal' : 'slow'\n  };\n  \n  return insights;\n}\n\n// Build the comprehensive response\nconst response = {\n  // Request summary\n  request: {\n    query: searchData.query,\n    intent: searchData.intent,\n    timestamp: timestamp,\n    processingTimeMs: searchData.processingTime\n  },\n  \n  // Search results summary\n  summary: {\n    totalResults: searchData.resultsFound,\n    uniqueVideos: searchData.searchMetadata.uniqueVideos,\n    averageRelevance: Math.round(searchData.searchMetadata.averageRelevance * 100) / 100,\n    filtersApplied: searchData.searchMetadata.filtersApplied,\n    searchType: searchData.searchMetadata.hybridSearchUsed ? 'hybrid' : 'semantic'\n  },\n  \n  // Quality breakdown\n  quality: {\n    excellent: searchData.quality.highRelevance,\n    good: searchData.quality.mediumRelevance,\n    fair: searchData.quality.lowRelevance,\n    diversityScore: Math.round(searchData.quality.diversityScore * 100) / 100\n  },\n  \n  // Formatted results\n  results: searchData.results.map(formatSearchResult),\n  \n  // Video groupings\n  videoGroups: searchData.videoGroups.map(formatVideoGroup),\n  \n  // Search suggestions and recommendations\n  suggestions: generateSearchSuggestions(searchData.query, searchData.intent, searchData.results),\n  \n  // Search insights\n  insights: generateSearchInsights(searchData),\n  \n  // Metadata for API consumers\n  metadata: {\n    searchId: 'search_' + Date.now(),\n    version: '1.0',\n    source: 'blox-wizard-semantic-search',\n    cacheHint: searchData.processingTime < 100 ? 'cached' : 'computed',\n    nextActions: {\n      refineSearch: '/api/search/semantic',\n      viewVideo: '/api/videos/{videoId}',\n      relatedSearch: '/api/search/related'\n    }\n  },\n  \n  // Performance analytics\n  performance: {\n    searchLatency: searchData.processingTime,\n    resultRelevance: searchData.searchMetadata.averageRelevance,\n    algorithmEfficiency: searchData.resultsFound / Math.max(1, searchData.totalResults),\n    userSatisfactionPrediction: calculateSatisfactionScore(searchData)\n  }\n};\n\n// Calculate predicted user satisfaction based on search quality\nfunction calculateSatisfactionScore(data) {\n  let score = 0;\n  \n  // Relevance contribution (50%)\n  score += data.searchMetadata.averageRelevance * 0.5;\n  \n  // Result count contribution (25%)\n  const resultRatio = Math.min(1, data.resultsFound / 5); // Optimal around 5 results\n  score += resultRatio * 0.25;\n  \n  // Diversity contribution (15%)\n  score += data.quality.diversityScore * 0.15;\n  \n  // Speed contribution (10%)\n  const speedScore = Math.max(0, 1 - (data.processingTime / 2000)); // Penalty after 2s\n  score += speedScore * 0.1;\n  \n  return Math.round(score * 100) / 100;\n}\n\nreturn [response];"
      },
      "id": "a7b8c9d0-e1f2-3456-a789-012345678901",
      "name": "üì§ Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 400],
      "onError": "continueRegularOutput",
      "notes": "üì§ COMPREHENSIVE SEARCH RESPONSE FORMATTER\n\nüéØ PURPOSE:\nTransforms processed search results into user-friendly, actionable responses:\n‚Ä¢ Formats results with clear structure and navigation aids\n‚Ä¢ Provides video groupings for organized content consumption\n‚Ä¢ Generates intelligent search suggestions and insights\n‚Ä¢ Includes performance metrics and quality assessments\n\nüìã RESPONSE STRUCTURE:\n\nüîç REQUEST SUMMARY:\n‚Ä¢ Original query and detected intent\n‚Ä¢ Processing timestamp and performance metrics\n‚Ä¢ Search type identification (semantic/hybrid)\n\nüìä RESULTS SUMMARY:\n‚Ä¢ Total results count and unique video coverage\n‚Ä¢ Average relevance score and quality distribution\n‚Ä¢ Applied filters and search configuration summary\n\n‚≠ê INDIVIDUAL RESULT FORMAT:\nEach result includes:\n‚Ä¢ Core content with relevance scoring\n‚Ä¢ Video information (title, timestamp, navigation)\n‚Ä¢ Learning context (module, week, difficulty, tags)\n‚Ä¢ Navigation helpers (direct links, formatted timestamps)\n‚Ä¢ Context enrichment (surrounding chunks if available)\n\nüìπ VIDEO GROUPINGS:\nOrganized by source video:\n‚Ä¢ Video metadata and learning context\n‚Ä¢ Match statistics (count, best score, average relevance)\n‚Ä¢ Formatted matches within each video\n‚Ä¢ Quick access to best match per video\n\nüí° INTELLIGENT SUGGESTIONS:\n\nüîÑ QUERY MODIFICATION SUGGESTIONS:\n‚Ä¢ Alternative keywords and synonyms for better results\n‚Ä¢ Query expansion tips for broader coverage\n‚Ä¢ Simplification advice for complex queries\n\nüéõÔ∏è FILTER OPTIMIZATION:\n‚Ä¢ Suggestions to broaden search scope\n‚Ä¢ Filter combination recommendations\n‚Ä¢ Content availability hints\n\nüéØ INTENT-BASED RECOMMENDATIONS:\n‚Ä¢ Tutorial series suggestions for learning paths\n‚Ä¢ Related content discovery hints\n‚Ä¢ Progressive learning recommendations\n\nüìà SEARCH INSIGHTS:\n\nüßÆ QUERY ANALYSIS:\n‚Ä¢ Complexity assessment (high/medium/low)\n‚Ä¢ Intent classification confidence\n‚Ä¢ Keyword effectiveness scoring\n\nüèÜ RESULT QUALITY METRICS:\n‚Ä¢ Quality tiers (excellent/good/fair)\n‚Ä¢ Content coverage breadth (broad/moderate/focused)\n‚Ä¢ Search efficiency assessment (fast/normal/slow)\n\nüéØ USER SATISFACTION PREDICTION:\nPredictive scoring based on:\n‚Ä¢ Relevance score contribution (50%)\n‚Ä¢ Result count optimization (25%)\n‚Ä¢ Content diversity factor (15%)\n‚Ä¢ Response speed factor (10%)\n\n‚ö° PERFORMANCE ANALYTICS:\n‚Ä¢ Search latency measurement\n‚Ä¢ Algorithm efficiency calculation\n‚Ä¢ Result relevance distribution\n‚Ä¢ Cache hit/miss indicators\n\nüîó NAVIGATION & INTEGRATION:\n‚Ä¢ Direct video links with timestamp navigation\n‚Ä¢ API endpoints for follow-up actions\n‚Ä¢ Related search suggestions\n‚Ä¢ Content exploration pathways\n\nüì± API CONSUMER METADATA:\n‚Ä¢ Unique search ID for tracking\n‚Ä¢ Version information for compatibility\n‚Ä¢ Source system identification\n‚Ä¢ Next action recommendations\n\n‚û°Ô∏è VALUE DELIVERED:\nRich, actionable search results that enable immediate content consumption, guided learning paths, and continuous search refinement for optimal user experience"
    },
    {
      "parameters": {
        "jsCode": "// ‚ùå SEARCH ERROR RESPONSE HANDLER\n// Generates comprehensive error responses for failed searches\n\nconst error = items[0].json.error || {};\nconst originalRequest = items[0].json;\nconst timestamp = new Date().toISOString();\n\n// Determine error category and provide specific guidance\nfunction categorizeSearchError(error, request) {\n  // Query validation errors\n  if (!request.query || request.query.trim().length === 0) {\n    return {\n      category: 'QUERY_VALIDATION_ERROR',\n      severity: 'medium',\n      userMessage: 'Please provide a search query',\n      technicalMessage: 'Missing or empty query parameter'\n    };\n  }\n  \n  if (request.query.length < 2) {\n    return {\n      category: 'QUERY_TOO_SHORT',\n      severity: 'low', \n      userMessage: 'Search query is too short. Please use at least 2 characters.',\n      technicalMessage: `Query length ${request.query.length} below minimum of 2 characters`\n    };\n  }\n  \n  if (request.query.length > 500) {\n    return {\n      category: 'QUERY_TOO_LONG',\n      severity: 'medium',\n      userMessage: 'Search query is too long. Please use fewer than 500 characters.',\n      technicalMessage: `Query length ${request.query.length} exceeds maximum of 500 characters`\n    };\n  }\n  \n  // Database/Vector store errors\n  if (error.message && error.message.includes('postgres')) {\n    return {\n      category: 'DATABASE_ERROR',\n      severity: 'high',\n      userMessage: 'Search service is temporarily unavailable. Please try again in a moment.',\n      technicalMessage: 'PostgreSQL connection or query error'\n    };\n  }\n  \n  if (error.message && error.message.includes('vector')) {\n    return {\n      category: 'VECTOR_SEARCH_ERROR',\n      severity: 'high',\n      userMessage: 'Semantic search is temporarily unavailable. Please try again.',\n      technicalMessage: 'Vector similarity search operation failed'\n    };\n  }\n  \n  // Processing errors\n  if (error.message && error.message.includes('timeout')) {\n    return {\n      category: 'SEARCH_TIMEOUT',\n      severity: 'medium',\n      userMessage: 'Search is taking longer than expected. Please try a simpler query.',\n      technicalMessage: 'Search operation exceeded timeout threshold'\n    };\n  }\n  \n  // Rate limiting\n  if (error.message && error.message.includes('rate')) {\n    return {\n      category: 'RATE_LIMITED',\n      severity: 'medium',\n      userMessage: 'Too many searches. Please wait a moment before searching again.',\n      technicalMessage: 'Rate limit exceeded for user/IP'\n    };\n  }\n  \n  // Default unknown error\n  return {\n    category: 'UNKNOWN_ERROR',\n    severity: 'medium',\n    userMessage: 'An unexpected error occurred. Please try again.',\n    technicalMessage: error.message || 'Unknown search error'\n  };\n}\n\n// Generate recovery suggestions based on error type\nfunction generateRecoverySuggestions(errorInfo, query) {\n  const suggestions = [];\n  \n  switch(errorInfo.category) {\n    case 'QUERY_VALIDATION_ERROR':\n    case 'QUERY_TOO_SHORT':\n      suggestions.push({\n        type: 'query_improvement',\n        title: 'Improve Your Search',\n        suggestion: 'Try using more descriptive keywords',\n        examples: ['\"how to script in roblox\"', '\"create gui tutorial\"', '\"roblox game mechanics\"']\n      });\n      break;\n      \n    case 'QUERY_TOO_LONG':\n      suggestions.push({\n        type: 'query_simplification',\n        title: 'Simplify Your Search', \n        suggestion: 'Focus on the main concepts you want to learn',\n        examples: ['Use key terms only', 'Remove unnecessary words', 'Split into multiple searches']\n      });\n      break;\n      \n    case 'DATABASE_ERROR':\n    case 'VECTOR_SEARCH_ERROR':\n      suggestions.push({\n        type: 'retry_later',\n        title: 'Try Again Soon',\n        suggestion: 'Our search service is experiencing issues',\n        examples: ['Wait 30 seconds and retry', 'Try browsing modules directly', 'Check system status page']\n      });\n      break;\n      \n    case 'SEARCH_TIMEOUT':\n      suggestions.push({\n        type: 'query_optimization',\n        title: 'Optimize Your Search',\n        suggestion: 'Try shorter, more specific queries',\n        examples: ['Use fewer keywords', 'Remove complex phrases', 'Search for specific topics']\n      });\n      break;\n      \n    case 'RATE_LIMITED':\n      suggestions.push({\n        type: 'wait_and_retry',\n        title: 'Slow Down Searches',\n        suggestion: 'Please wait before searching again',\n        examples: ['Wait 60 seconds', 'Browse existing content', 'Refine your query while waiting']\n      });\n      break;\n      \n    default:\n      suggestions.push({\n        type: 'general_help',\n        title: 'Search Tips',\n        suggestion: 'Try these general search improvements',\n        examples: ['Use clear, simple language', 'Try different keywords', 'Check for typos']\n      });\n  }\n  \n  return suggestions;\n}\n\n// Generate alternative search approaches\nfunction generateAlternatives(query, errorInfo) {\n  const alternatives = [];\n  \n  if (query && query.length > 0) {\n    // Suggest simplified version\n    const words = query.split(' ').filter(w => w.length > 2);\n    if (words.length > 2) {\n      alternatives.push({\n        type: 'simplified_query',\n        query: words.slice(0, 2).join(' '),\n        description: 'Try a simpler version with key terms only'\n      });\n    }\n    \n    // Suggest synonyms for common terms\n    const synonymSuggestions = {\n      'script': 'code',\n      'gui': 'interface',\n      'part': 'object', \n      'player': 'character',\n      'create': 'make',\n      'build': 'create'\n    };\n    \n    let alternativeQuery = query.toLowerCase();\n    for (const [original, synonym] of Object.entries(synonymSuggestions)) {\n      if (alternativeQuery.includes(original)) {\n        alternativeQuery = alternativeQuery.replace(original, synonym);\n        alternatives.push({\n          type: 'synonym_suggestion',\n          query: alternativeQuery,\n          description: `Try using \"${synonym}\" instead of \"${original}\"`\n        });\n        break;\n      }\n    }\n  }\n  \n  // Suggest browsing by category if search fails\n  alternatives.push({\n    type: 'browse_categories',\n    categories: ['Scripting Basics', 'GUI Design', 'Game Mechanics', 'Advanced Scripting'],\n    description: 'Browse content by category instead of searching'\n  });\n  \n  return alternatives;\n}\n\n// Build comprehensive error response\nconst errorInfo = categorizeSearchError(error, originalRequest);\nconst recoverySuggestions = generateRecoverySuggestions(errorInfo, originalRequest.query);\nconst alternatives = generateAlternatives(originalRequest.query, errorInfo);\n\nconst errorResponse = {\n  success: false,\n  operation: 'semantic_search_failed',\n  timestamp: timestamp,\n  \n  // Error classification\n  error: {\n    category: errorInfo.category,\n    severity: errorInfo.severity,\n    message: errorInfo.userMessage,\n    technicalDetails: errorInfo.technicalMessage,\n    code: error.code || 'SEARCH_ERROR'\n  },\n  \n  // Original request context\n  request: {\n    query: originalRequest.query || '',\n    userId: originalRequest.userId || null,\n    sessionId: originalRequest.sessionId || null,\n    hasFilters: originalRequest.filters && Object.keys(originalRequest.filters).length > 0\n  },\n  \n  // Recovery guidance\n  recovery: {\n    canRetry: ['DATABASE_ERROR', 'VECTOR_SEARCH_ERROR', 'SEARCH_TIMEOUT'].includes(errorInfo.category),\n    retryDelay: errorInfo.category === 'RATE_LIMITED' ? 60000 : 5000, // milliseconds\n    suggestions: recoverySuggestions,\n    alternatives: alternatives\n  },\n  \n  // Help and support\n  help: {\n    searchTips: [\n      'Use clear, descriptive keywords',\n      'Try different phrasings of your question', \n      'Check spelling and grammar',\n      'Use 2-10 keywords for best results',\n      'Be specific about what you want to learn'\n    ],\n    commonQueries: [\n      'how to create a script',\n      'roblox gui tutorial',\n      'player movement script',\n      'game mechanics basics'\n    ],\n    supportOptions: [\n      {\n        type: 'documentation',\n        title: 'Search Help Guide',\n        url: '/docs/search-help'\n      },\n      {\n        type: 'community',\n        title: 'Community Forum',\n        url: '/community/search-help'\n      },\n      {\n        type: 'contact',\n        title: 'Contact Support',\n        url: '/support/contact'\n      }\n    ]\n  },\n  \n  // Analytics for error tracking\n  analytics: {\n    errorId: 'err_' + Date.now(),\n    userAgent: originalRequest.userAgent || 'unknown',\n    searchPattern: originalRequest.query ? originalRequest.query.length + '_chars' : 'no_query',\n    hasRetried: originalRequest.retryCount > 0,\n    sessionContext: !!originalRequest.sessionId\n  }\n};\n\nreturn [errorResponse];"
      },
      "id": "b8c9d0e1-f2a3-4567-b890-123456789012",
      "name": "‚ùå Search Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 600],
      "onError": "continueRegularOutput",
      "notes": "‚ùå COMPREHENSIVE SEARCH ERROR HANDLER\n\nüéØ PURPOSE:\nProvides intelligent error handling and recovery guidance for search failures:\n‚Ä¢ Categorizes errors by type and severity for appropriate responses\n‚Ä¢ Generates user-friendly error messages with actionable guidance\n‚Ä¢ Provides specific recovery suggestions based on error context\n‚Ä¢ Offers alternative search approaches and browsing options\n\nüîç ERROR CATEGORIZATION:\n\nüìù QUERY VALIDATION ERRORS:\n‚Ä¢ QUERY_VALIDATION_ERROR: Missing or empty search query\n‚Ä¢ QUERY_TOO_SHORT: Less than 2 characters (low severity)\n‚Ä¢ QUERY_TOO_LONG: More than 500 characters (medium severity)\n‚Ä¢ Provides specific character count guidance and examples\n\nüíæ SYSTEM ERRORS:\n‚Ä¢ DATABASE_ERROR: PostgreSQL connection or query failures\n‚Ä¢ VECTOR_SEARCH_ERROR: Embedding similarity search issues\n‚Ä¢ High severity requiring immediate attention and retry logic\n\n‚è±Ô∏è PERFORMANCE ERRORS:\n‚Ä¢ SEARCH_TIMEOUT: Operations exceeding time limits\n‚Ä¢ Suggests query simplification and optimization strategies\n‚Ä¢ Medium severity with user-actionable solutions\n\nüö¶ RATE LIMITING:\n‚Ä¢ RATE_LIMITED: Too many requests from user/IP\n‚Ä¢ Provides specific wait times and alternative actions\n‚Ä¢ Protects system resources while guiding users\n\nüõ†Ô∏è RECOVERY STRATEGIES:\n\nüîÑ RETRY LOGIC:\n‚Ä¢ Intelligent retry recommendations based on error type\n‚Ä¢ Specific delay suggestions (5s for system errors, 60s for rate limits)\n‚Ä¢ Retry feasibility assessment per error category\n\nüí° QUERY IMPROVEMENT SUGGESTIONS:\n‚Ä¢ Descriptive keyword recommendations for short queries\n‚Ä¢ Simplification advice for overly complex searches\n‚Ä¢ Synonym suggestions for common Roblox terminology\n‚Ä¢ Example queries demonstrating best practices\n\nüîÄ ALTERNATIVE APPROACHES:\n‚Ä¢ Simplified query generation (key terms only)\n‚Ä¢ Synonym-based query alternatives\n‚Ä¢ Category browsing suggestions when search fails\n‚Ä¢ Progressive query refinement strategies\n\nüìö USER GUIDANCE:\n\nüéØ SEARCH OPTIMIZATION TIPS:\n‚Ä¢ Clear, descriptive keyword usage\n‚Ä¢ Optimal query length recommendations (2-10 keywords)\n‚Ä¢ Spelling and grammar importance\n‚Ä¢ Specific learning goal articulation\n\nüìñ EDUCATIONAL RESOURCES:\n‚Ä¢ Search help documentation links\n‚Ä¢ Community forum guidance\n‚Ä¢ Support contact information\n‚Ä¢ Best practice examples and tutorials\n\nüîç COMMON QUERY EXAMPLES:\n‚Ä¢ \"how to create a script\" - Tutorial requests\n‚Ä¢ \"roblox gui tutorial\" - Interface design help\n‚Ä¢ \"player movement script\" - Specific functionality\n‚Ä¢ \"game mechanics basics\" - Foundational concepts\n\nüìä ERROR ANALYTICS:\n‚Ä¢ Unique error ID for tracking and debugging\n‚Ä¢ User agent and session context capture\n‚Ä¢ Search pattern analysis for improvement insights\n‚Ä¢ Retry attempt tracking for success rate analysis\n\nüé® USER EXPERIENCE FOCUS:\n‚Ä¢ Non-technical error messages for general users\n‚Ä¢ Progressive disclosure of technical details\n‚Ä¢ Immediate actionable guidance over generic messages\n‚Ä¢ Contextual help based on specific error scenarios\n\n‚û°Ô∏è VALUE DELIVERED:\nTransforms search failures into learning opportunities with clear guidance, alternative paths, and educational resources that keep users engaged and successful"
    }
  ],
  "connections": {
    "üåê Semantic Search Webhook": {
      "main": [
        [
          {
            "node": "‚úÖ Query Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "‚úÖ Query Validator": {
      "main": [
        [
          {
            "node": "üîç Query Enhancement",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "‚ùå Search Error Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Query Enhancement": {
      "main": [
        [
          {
            "node": "üîç Vector Similarity Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Vector Similarity Search": {
      "main": [
        [
          {
            "node": "üìä Process Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Process Search Results": {
      "main": [
        [
          {
            "node": "üì° Publish Search Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì° Publish Search Event": {
      "main": [
        [
          {
            "node": "üì§ Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-30T14:00:00.000Z",
      "updatedAt": "2025-01-30T14:00:00.000Z",
      "id": "semantic-search",
      "name": "semantic-search"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-30T14:00:00.000Z",
  "versionId": "semantic-search-v1"
}