{
  "name": "ğŸ—ƒï¸ State Manager",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "state-manager",
        "responseMode": "lastNode",
        "responseData": "allEntries",
        "options": {}
      },
      "id": "f88ad8d7-4100-4c2f-b3e4-6f7a5e2c8d91",
      "name": "ğŸ“¥ State Manager Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [280, 400],
      "webhookId": "state-manager-webhook",
      "onError": "continueRegularOutput",
      "notes": "ğŸšª MAIN ENTRY POINT - State Manager Webhook\n\nğŸ¯ PURPOSE:\nHandles all state management operations including:\nâ€¢ User session creation/updates\nâ€¢ Learning context persistence\nâ€¢ Cross-workflow state synchronization\nâ€¢ Context retrieval for other subsystems\n\nğŸ“ EXPECTED PAYLOAD:\n{\n  \"action\": \"get|set|update|delete\",\n  \"userId\": \"string\",\n  \"sessionId\": \"string\", \n  \"contextType\": \"user|learning|system\",\n  \"data\": {},\n  \"ttl\": 3600\n}\n\nâœ… SECURITY:\nâ€¢ Validates user permissions\nâ€¢ Sanitizes input data\nâ€¢ Rate limiting applied\nâ€¢ Audit logging enabled\n\nğŸ”„ FLOW:\nWebhook â†’ Input Validation â†’ Action Router â†’ State Operations â†’ Response"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "required_fields_check",
              "leftValue": "={{ $json.action && $json.userId && $json.contextType }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "a7b2c9f4-8d1e-4567-a890-1234567890ab",
      "name": "âœ… Input Validator",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [500, 400],
      "onError": "continueRegularOutput",
      "notes": "ğŸ” INPUT VALIDATION CHECKPOINT\n\nğŸ¯ PURPOSE:\nValidates incoming requests have required fields:\nâ€¢ action: Operation type (get/set/update/delete)\nâ€¢ userId: Target user identifier\nâ€¢ contextType: Type of context (user/learning/system)\n\nâœ… VALIDATION RULES:\nâ€¢ Required fields present\nâ€¢ Action is valid operation\nâ€¢ UserId format validation\nâ€¢ ContextType enum validation\nâ€¢ Data structure validation\n\nâŒ FAILURE HANDLING:\nâ€¢ Invalid requests â†’ Error Response\nâ€¢ Missing fields â†’ 400 Bad Request\nâ€¢ Malformed data â†’ Sanitization attempt\nâ€¢ Security violations â†’ Alert & Block\n\nâ¡ï¸ ROUTING:\nValid â†’ Continue to Action Router\nInvalid â†’ Error Response Node"
    },
    {
      "parameters": {
        "mode": "expression",
        "output1": "get_state",
        "output2": "set_state", 
        "output3": "update_state",
        "output4": "delete_state",
        "rules": {
          "rules": [
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "get",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "get_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "set", 
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "set_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "update",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "update_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "delete",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "delete_state"
            }
          ]
        },
        "options": {}
      },
      "id": "b8c3d0e5-9f2a-4678-b901-234567890bcd",
      "name": "ğŸ”€ Action Router",
      "type": "n8n-nodes-base.switch", 
      "typeVersion": 3,
      "position": [720, 400],
      "onError": "continueRegularOutput",
      "notes": "ğŸš¦ ACTION ROUTING HUB\n\nğŸ¯ PURPOSE:\nRoutes validated requests to appropriate state operations:\nâ€¢ GET â†’ Retrieve existing state data\nâ€¢ SET â†’ Create new state entries\nâ€¢ UPDATE â†’ Modify existing state data\nâ€¢ DELETE â†’ Remove state entries\n\nğŸ“Š ROUTING LOGIC:\nAnalyzes 'action' field and directs to specialized handlers:\n\nğŸ” GET Operations:\nâ€¢ User profile retrieval\nâ€¢ Learning progress queries\nâ€¢ Session context lookup\nâ€¢ Cross-workflow state access\n\nğŸ’¾ SET Operations:\nâ€¢ New user session creation\nâ€¢ Initial context establishment\nâ€¢ First-time state initialization\nâ€¢ Workflow registration\n\nğŸ”„ UPDATE Operations:\nâ€¢ Learning progress updates\nâ€¢ Session data modifications\nâ€¢ Context synchronization\nâ€¢ Performance metric updates\n\nğŸ—‘ï¸ DELETE Operations:\nâ€¢ Session cleanup\nâ€¢ Context expiration\nâ€¢ User data removal (GDPR)\nâ€¢ Temporary state clearing\n\nâ¡ï¸ OUTPUT PORTS:\nget_state | set_state | update_state | delete_state"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "stateData",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}",
        "keyType": "automatic"
      },
      "id": "c9d4e1f6-0a3b-5789-c012-34567890cdef",
      "name": "ğŸ” Get State from Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [940, 200],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ“¥ STATE RETRIEVAL ENGINE\n\nğŸ¯ PURPOSE:\nRetrieves user state data from Redis cache:\nâ€¢ User profiles and preferences\nâ€¢ Learning progress and context\nâ€¢ Session data and activity\nâ€¢ Cross-workflow shared state\n\nğŸ”‘ KEY STRUCTURE:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\nExamples:\nâ€¢ user_state:user123:learning:session456\nâ€¢ user_state:user123:profile\nâ€¢ user_state:user123:system:workflow789\n\nğŸ“Š CONTEXT TYPES:\nâ€¢ user: Profile, preferences, settings\nâ€¢ learning: Progress, current module, achievements\nâ€¢ system: Workflow state, error context, metrics\nâ€¢ session: Temporary interaction data\n\nâœ… FEATURES:\nâ€¢ Automatic key type detection\nâ€¢ JSON deserialization\nâ€¢ Cache hit/miss tracking\nâ€¢ Performance monitoring\n\nâŒ ERROR HANDLING:\nâ€¢ Key not found â†’ Default empty state\nâ€¢ Redis connection issues â†’ Fallback to DB\nâ€¢ Malformed data â†’ Log error & return empty\nâ€¢ Permission denied â†’ Access control response\n\nâ¡ï¸ NEXT STEPS:\nFound â†’ Format Response\nNot Found â†’ Default State Response"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}",
        "value": "={{ JSON.stringify($json.data) }}",
        "expire": true,
        "ttl": "={{ $json.ttl || 3600 }}"
      },
      "id": "d0e5f2a7-1b4c-6890-d123-45678901defa",
      "name": "ğŸ’¾ Set State in Redis", 
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [940, 400],
      "credentials": {
        "redis": {
          "id": "redis-credentials", 
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ’¾ STATE STORAGE ENGINE\n\nğŸ¯ PURPOSE:\nStores new state data in Redis with TTL management:\nâ€¢ Creates new user sessions\nâ€¢ Initializes learning contexts\nâ€¢ Establishes workflow state\nâ€¢ Manages temporary data\n\nğŸ”‘ KEY STRATEGY:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\nâ° TTL MANAGEMENT:\nâ€¢ Default: 1 hour (3600s)\nâ€¢ User sessions: 4 hours\nâ€¢ Learning context: 24 hours\nâ€¢ System state: 1 hour\nâ€¢ Custom TTL via request payload\n\nğŸ“¦ DATA HANDLING:\nâ€¢ JSON serialization of complex objects\nâ€¢ Validates data structure before storage\nâ€¢ Compresses large payloads automatically\nâ€¢ Maintains data integrity checks\n\nâœ… STORAGE FEATURES:\nâ€¢ Atomic operations\nâ€¢ Expiration management\nâ€¢ Memory optimization\nâ€¢ Concurrent access safety\n\nğŸ“Š MONITORING:\nâ€¢ Storage success/failure rates\nâ€¢ Memory usage tracking\nâ€¢ Key expiration analytics\nâ€¢ Performance metrics\n\nâ¡ï¸ NEXT STEPS:\nSuccess â†’ Confirmation Response\nFailure â†’ Error Handling & Retry"
    },
    {
      "parameters": {
        "jsCode": "// ğŸ”„ STATE UPDATE PROCESSOR\n// Handles intelligent merging of existing state with new data\n\nconst existingKey = 'user_state:' + items[0].json.userId + ':' + items[0].json.contextType + (items[0].json.sessionId ? ':' + items[0].json.sessionId : '');\nconst newData = items[0].json.data || {};\nconst mergeStrategy = items[0].json.mergeStrategy || 'deep';\nconst timestamp = new Date().toISOString();\n\n// First, we need to get existing state\n// This will be handled by a Redis GET operation before this node\n\n// For now, prepare the update data\nconst updatePayload = {\n  key: existingKey,\n  newData: newData,\n  mergeStrategy: mergeStrategy,\n  timestamp: timestamp,\n  userId: items[0].json.userId,\n  contextType: items[0].json.contextType,\n  sessionId: items[0].json.sessionId,\n  ttl: items[0].json.ttl || 3600\n};\n\n// Add metadata for tracking\nupdatePayload.metadata = {\n  operation: 'update',\n  requestId: items[0].json.requestId || 'req_' + Date.now(),\n  source: items[0].json.source || 'state-manager',\n  version: '1.0'\n};\n\nreturn [updatePayload];"
      },
      "id": "e1f6a3b8-2c5d-7901-e234-56789012efab",
      "name": "ğŸ”„ Prepare State Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 600],
      "onError": "continueRegularOutput", 
      "notes": "ğŸ”„ STATE UPDATE PREPARATION\n\nğŸ¯ PURPOSE:\nPrepares intelligent state updates with merge strategies:\nâ€¢ Deep merge for complex objects\nâ€¢ Shallow merge for simple updates\nâ€¢ Array append/replace operations\nâ€¢ Timestamp tracking and versioning\n\nğŸ”€ MERGE STRATEGIES:\nâ€¢ deep: Recursive object merging (default)\nâ€¢ shallow: Top-level property replacement\nâ€¢ replace: Complete state replacement\nâ€¢ append: Add to existing arrays\nâ€¢ increment: Numeric value updates\n\nğŸ“Š UPDATE TYPES:\nâ€¢ Learning progress increments\nâ€¢ Session data modifications\nâ€¢ User preference updates\nâ€¢ Workflow state changes\nâ€¢ Performance metric updates\n\nğŸ•’ VERSIONING:\nâ€¢ Timestamp all updates\nâ€¢ Track change history\nâ€¢ Maintain audit trail\nâ€¢ Enable rollback capability\n\nâœ… FEATURES:\nâ€¢ Conflict resolution\nâ€¢ Data validation before merge\nâ€¢ Type safety enforcement\nâ€¢ Metadata enrichment\n\nğŸ“ METADATA:\nâ€¢ RequestId for tracing\nâ€¢ Source system identification\nâ€¢ Operation type logging\nâ€¢ Version tracking\n\nâ¡ï¸ NEXT STEPS:\nPrepared â†’ Get Existing State\nMerged â†’ Update Redis\nValidated â†’ Success Response"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}"
      },
      "id": "f2a7b4c9-3d6e-8012-f345-67890123fabc",
      "name": "ğŸ—‘ï¸ Delete State from Redis",
      "type": "n8n-nodes-base.redis", 
      "typeVersion": 1,
      "position": [940, 800],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ—‘ï¸ STATE DELETION ENGINE\n\nğŸ¯ PURPOSE:\nSafely removes state data from Redis cache:\nâ€¢ Session cleanup after logout\nâ€¢ Expired context removal\nâ€¢ GDPR compliance deletions\nâ€¢ Temporary state clearing\nâ€¢ System maintenance cleanup\n\nğŸ”‘ DELETION SCOPE:\nTargets specific keys matching pattern:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\nğŸ›¡ï¸ SAFETY MEASURES:\nâ€¢ Confirmation before critical deletions\nâ€¢ Backup critical data before removal\nâ€¢ Audit logging for all deletions\nâ€¢ Permission validation\nâ€¢ Cascading delete prevention\n\nğŸ“Š DELETION TYPES:\nâ€¢ Session cleanup (automatic)\nâ€¢ User-requested removal\nâ€¢ System maintenance\nâ€¢ Privacy compliance (GDPR)\nâ€¢ Error state clearing\n\nâœ… VERIFICATION:\nâ€¢ Confirms key existence before deletion\nâ€¢ Validates user permissions\nâ€¢ Logs deletion operations\nâ€¢ Returns deletion confirmation\n\nâš ï¸ CRITICAL CONTEXTS:\nâ€¢ learning: Check for unsaved progress\nâ€¢ profile: Require explicit confirmation\nâ€¢ system: Validate admin permissions\nâ€¢ session: Safe for automatic cleanup\n\nğŸ“ AUDIT TRAIL:\nâ€¢ Deletion timestamp\nâ€¢ Requesting user/system\nâ€¢ Deletion reason\nâ€¢ Recovery information\n\nâ¡ï¸ NEXT STEPS:\nDeleted â†’ Confirmation Response\nFailed â†’ Error Response\nBlocked â†’ Permission Denied"
    },
    {
      "parameters": {
        "jsCode": "// ğŸ“¤ STATE RESPONSE FORMATTER\n// Standardizes all state manager responses\n\nconst inputData = items[0].json;\nconst operation = inputData.operation || $node['Action Router'].json.action || 'unknown';\nconst success = !inputData.error;\nconst timestamp = new Date().toISOString();\n\n// Base response structure\nlet response = {\n  success: success,\n  operation: operation,\n  timestamp: timestamp,\n  userId: inputData.userId,\n  contextType: inputData.contextType,\n  sessionId: inputData.sessionId || null\n};\n\n// Add operation-specific data\nswitch(operation) {\n  case 'get':\n    response.data = inputData.data || null;\n    response.found = !!inputData.data;\n    response.cacheHit = true;\n    break;\n    \n  case 'set':\n    response.created = success;\n    response.ttl = inputData.ttl || 3600;\n    response.key = inputData.key;\n    break;\n    \n  case 'update':\n    response.updated = success;\n    response.changes = inputData.changes || {};\n    response.version = inputData.version || '1.0';\n    break;\n    \n  case 'delete':\n    response.deleted = success;\n    response.key = inputData.key;\n    break;\n    \n  default:\n    response.message = 'Unknown operation';\n}\n\n// Add metadata\nresponse.metadata = {\n  requestId: inputData.requestId || 'req_' + Date.now(),\n  processingTime: Date.now() - (inputData.startTime || Date.now()),\n  workflow: 'state-manager',\n  version: '1.0'\n};\n\n// Add error details if present\nif (!success && inputData.error) {\n  response.error = {\n    code: inputData.error.code || 'UNKNOWN_ERROR',\n    message: inputData.error.message || 'An error occurred',\n    details: inputData.error.details || {}\n  };\n}\n\nreturn [response];"
      },
      "id": "a3b8c5d0-4e7f-9123-a456-78901234bcde",
      "name": "ğŸ“¤ Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1160, 400],
      "onError": "continueRegularOutput",
      "notes": "ğŸ“¤ RESPONSE FORMATTING ENGINE\n\nğŸ¯ PURPOSE:\nStandardizes all State Manager responses across operations:\nâ€¢ Uniform response structure\nâ€¢ Operation-specific data inclusion\nâ€¢ Error handling and messaging\nâ€¢ Performance metrics embedding\nâ€¢ Audit trail information\n\nğŸ“‹ RESPONSE STRUCTURE:\n{\n  \"success\": boolean,\n  \"operation\": \"get|set|update|delete\",\n  \"timestamp\": \"ISO string\",\n  \"userId\": \"string\",\n  \"contextType\": \"user|learning|system\",\n  \"data\": {}, // Operation-specific\n  \"metadata\": {}\n}\n\nğŸ” GET RESPONSES:\nâ€¢ data: Retrieved state object\nâ€¢ found: Boolean existence flag\nâ€¢ cacheHit: Performance indicator\n\nğŸ’¾ SET RESPONSES:\nâ€¢ created: Success confirmation\nâ€¢ ttl: Expiration time set\nâ€¢ key: Redis key created\n\nğŸ”„ UPDATE RESPONSES:\nâ€¢ updated: Modification success\nâ€¢ changes: Applied changes summary\nâ€¢ version: State version number\n\nğŸ—‘ï¸ DELETE RESPONSES:\nâ€¢ deleted: Removal confirmation\nâ€¢ key: Deleted Redis key\n\nğŸ“Š METADATA INCLUDED:\nâ€¢ requestId: Unique request identifier\nâ€¢ processingTime: Operation duration\nâ€¢ workflow: Source workflow name\nâ€¢ version: Response format version\n\nâ¡ï¸ FINAL OUTPUT:\nStandardized JSON response for all operations"
    },
    {
      "parameters": {
        "jsCode": "// âŒ ERROR RESPONSE HANDLER\n// Generates standardized error responses for failed operations\n\nconst error = items[0].json.error || {};\nconst originalRequest = items[0].json;\nconst timestamp = new Date().toISOString();\n\n// Standard error response structure\nconst errorResponse = {\n  success: false,\n  operation: originalRequest.action || 'unknown',\n  timestamp: timestamp,\n  userId: originalRequest.userId || null,\n  contextType: originalRequest.contextType || null,\n  sessionId: originalRequest.sessionId || null,\n  error: {\n    code: error.code || 'VALIDATION_ERROR',\n    message: error.message || 'Request validation failed',\n    details: error.details || {\n      missingFields: [],\n      invalidFields: [],\n      suggestions: []\n    }\n  },\n  metadata: {\n    requestId: originalRequest.requestId || 'req_' + Date.now(),\n    workflow: 'state-manager',\n    errorTimestamp: timestamp,\n    version: '1.0'\n  }\n};\n\n// Add specific error details based on validation failure\nif (!originalRequest.action) {\n  errorResponse.error.details.missingFields.push('action');\n  errorResponse.error.details.suggestions.push('Include action field: get, set, update, or delete');\n}\n\nif (!originalRequest.userId) {\n  errorResponse.error.details.missingFields.push('userId');\n  errorResponse.error.details.suggestions.push('Include userId field with valid user identifier');\n}\n\nif (!originalRequest.contextType) {\n  errorResponse.error.details.missingFields.push('contextType');\n  errorResponse.error.details.suggestions.push('Include contextType: user, learning, or system');\n}\n\nreturn [errorResponse];"
      },
      "id": "b4c9d6e1-5f8a-0234-b567-89012345cdef",
      "name": "âŒ Error Response Handler",
      "type": "n8n-nodes-base.code", 
      "typeVersion": 2,
      "position": [720, 600],
      "onError": "continueRegularOutput",
      "notes": "âŒ ERROR RESPONSE GENERATOR\n\nğŸ¯ PURPOSE:\nGenerates standardized error responses for validation failures:\nâ€¢ Missing required fields\nâ€¢ Invalid operation types\nâ€¢ Malformed request data\nâ€¢ Authentication failures\nâ€¢ Permission violations\n\nğŸ“‹ ERROR RESPONSE STRUCTURE:\n{\n  \"success\": false,\n  \"operation\": \"attempted_operation\",\n  \"timestamp\": \"ISO_string\", \n  \"error\": {\n    \"code\": \"ERROR_CODE\",\n    \"message\": \"Human readable message\",\n    \"details\": {\n      \"missingFields\": [],\n      \"invalidFields\": [],\n      \"suggestions\": []\n    }\n  }\n}\n\nğŸ” ERROR CATEGORIES:\nâ€¢ VALIDATION_ERROR: Missing/invalid fields\nâ€¢ PERMISSION_DENIED: Access control failures\nâ€¢ RATE_LIMITED: Too many requests\nâ€¢ SYSTEM_ERROR: Internal failures\nâ€¢ NOT_FOUND: Resource doesn't exist\n\nğŸ“ DETAILED FEEDBACK:\nâ€¢ Lists specific missing fields\nâ€¢ Identifies invalid field values\nâ€¢ Provides actionable suggestions\nâ€¢ Includes example correct formats\n\nğŸ›¡ï¸ SECURITY FEATURES:\nâ€¢ Sanitizes error messages\nâ€¢ Prevents information leakage\nâ€¢ Logs security violations\nâ€¢ Rate limiting violation tracking\n\nğŸ“Š ERROR ANALYTICS:\nâ€¢ Error frequency tracking\nâ€¢ Common failure patterns\nâ€¢ Client error distribution\nâ€¢ Performance impact metrics\n\nâ¡ï¸ FINAL OUTPUT:\nStandardized error response with helpful debugging information"
    },
    {
      "parameters": {
        "operation": "publish",
        "channel": "state_events",
        "messageData": "={{ JSON.stringify({\n  event: 'state_changed',\n  userId: $json.userId,\n  contextType: $json.contextType,\n  sessionId: $json.sessionId,\n  operation: $json.operation,\n  timestamp: new Date().toISOString(),\n  source: 'state-manager'\n}) }}"
      },
      "id": "c5d0e7f2-6a9b-1345-c678-90123456defa",
      "name": "ğŸ“¡ Publish State Event",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1160, 600],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ“¡ STATE EVENT BROADCASTER\n\nğŸ¯ PURPOSE:\nBroadcasts state changes to other subsystems via Redis pub/sub:\nâ€¢ Knowledge Engine context updates\nâ€¢ Scheduler behavior adaptations\nâ€¢ Analytics pattern tracking\nâ€¢ Real-time dashboard updates\nâ€¢ Cross-workflow synchronization\n\nğŸ“º CHANNEL: state_events\nAll subsystems subscribe to receive notifications\n\nğŸ“¦ EVENT PAYLOAD:\n{\n  \"event\": \"state_changed\",\n  \"userId\": \"string\",\n  \"contextType\": \"user|learning|system\",\n  \"sessionId\": \"string|null\",\n  \"operation\": \"get|set|update|delete\",\n  \"timestamp\": \"ISO_string\",\n  \"source\": \"state-manager\"\n}\n\nğŸ§ SUBSCRIBERS:\nâ€¢ Knowledge Engine: Updates user context for better responses\nâ€¢ Daily Scheduler: Adapts recommendations based on state changes\nâ€¢ Analytics System: Tracks user behavior patterns\nâ€¢ Master Orchestrator: Maintains global system state\nâ€¢ Error Handler: Context for error resolution\n\nğŸš€ REAL-TIME BENEFITS:\nâ€¢ Instant cross-system synchronization\nâ€¢ Reduced database polling\nâ€¢ Event-driven architecture\nâ€¢ Decoupled system communication\nâ€¢ Scalable message distribution\n\nğŸ“Š EVENT TYPES:\nâ€¢ User login/logout state changes\nâ€¢ Learning progress updates\nâ€¢ Preference modifications\nâ€¢ Session creation/expiration\nâ€¢ System state transitions\n\nâš¡ PERFORMANCE:\nâ€¢ Async non-blocking publish\nâ€¢ Minimal payload for speed\nâ€¢ Reliable delivery guarantee\nâ€¢ Channel-based routing\n\nâ¡ï¸ NEXT STEPS:\nEvent Published â†’ Continue Processing\nFailed Publish â†’ Log Error (Non-blocking)"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "existingData",
        "key": "={{ $json.key }}",
        "keyType": "automatic"
      },
      "id": "d6e1f8a3-7b0c-2456-d789-01234567efab",
      "name": "ğŸ” Get Existing State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [720, 800],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ” EXISTING STATE RETRIEVAL\n\nğŸ¯ PURPOSE:\nRetrieves current state data before updates for intelligent merging:\nâ€¢ Prevents data loss during updates\nâ€¢ Enables conflict resolution\nâ€¢ Supports incremental changes\nâ€¢ Maintains data consistency\nâ€¢ Enables rollback capabilities\n\nğŸ”— UPDATE FLOW:\n1. Get current state (this node)\n2. Merge with new data (Merge State)\n3. Save updated state (Update Redis)\n4. Publish change event\n5. Return confirmation\n\nğŸ“Š MERGE STRATEGIES SUPPORTED:\nâ€¢ deep: Recursive object merging\nâ€¢ shallow: Top-level property replacement\nâ€¢ replace: Complete state replacement\nâ€¢ append: Array/list additions\nâ€¢ increment: Numeric modifications\n\nâœ… DATA SAFETY:\nâ€¢ Atomic read operations\nâ€¢ Consistent state snapshots\nâ€¢ Version conflict detection\nâ€¢ Concurrent access handling\n\nğŸ”„ HANDLING SCENARIOS:\nâ€¢ State exists: Proceed with merge\nâ€¢ State missing: Create new state\nâ€¢ State corrupted: Initialize default\nâ€¢ Permission denied: Error response\n\nğŸ“ TRACKING:\nâ€¢ Read operation metrics\nâ€¢ Cache hit/miss rates\nâ€¢ Data consistency checks\nâ€¢ Performance monitoring\n\nâ¡ï¸ NEXT STEPS:\nFound â†’ Merge State\nNot Found â†’ Create New State\nError â†’ Error Handler"
    },
    {
      "parameters": {
        "jsCode": "// ğŸ”€ STATE MERGE PROCESSOR\n// Intelligently merges existing state with new data\n\nconst existingState = items[0].json.existingData ? JSON.parse(items[0].json.existingData) : {};\nconst newData = items[0].json.newData || {};\nconst mergeStrategy = items[0].json.mergeStrategy || 'deep';\nconst userId = items[0].json.userId;\nconst contextType = items[0].json.contextType;\nconst sessionId = items[0].json.sessionId;\nconst ttl = items[0].json.ttl;\nconst timestamp = new Date().toISOString();\n\n// Deep merge function\nfunction deepMerge(target, source) {\n  const output = Object.assign({}, target);\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key])) {\n        if (!(key in target))\n          Object.assign(output, { [key]: source[key] });\n        else\n          output[key] = deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nfunction isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n// Apply merge strategy\nlet mergedState;\nswitch(mergeStrategy) {\n  case 'deep':\n    mergedState = deepMerge(existingState, newData);\n    break;\n  case 'shallow':\n    mergedState = Object.assign({}, existingState, newData);\n    break;\n  case 'replace':\n    mergedState = newData;\n    break;\n  case 'append':\n    mergedState = existingState;\n    Object.keys(newData).forEach(key => {\n      if (Array.isArray(existingState[key]) && Array.isArray(newData[key])) {\n        mergedState[key] = [...existingState[key], ...newData[key]];\n      } else {\n        mergedState[key] = newData[key];\n      }\n    });\n    break;\n  default:\n    mergedState = deepMerge(existingState, newData);\n}\n\n// Add metadata\nmergedState._metadata = {\n  lastUpdated: timestamp,\n  version: (existingState._metadata?.version || 0) + 1,\n  updateStrategy: mergeStrategy,\n  userId: userId,\n  contextType: contextType\n};\n\n// Prepare for Redis update\nconst result = {\n  key: 'user_state:' + userId + ':' + contextType + (sessionId ? ':' + sessionId : ''),\n  value: JSON.stringify(mergedState),\n  ttl: ttl || 3600,\n  mergedState: mergedState,\n  operation: 'update',\n  userId: userId,\n  contextType: contextType,\n  sessionId: sessionId,\n  changes: {\n    added: Object.keys(newData),\n    strategy: mergeStrategy,\n    version: mergedState._metadata.version\n  }\n};\n\nreturn [result];"
      },
      "id": "e7f2a9b4-8c1d-3567-e890-12345678fabc",
      "name": "ğŸ”€ Merge State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 1000],
      "onError": "continueRegularOutput",
      "notes": "ğŸ”€ INTELLIGENT STATE MERGER\n\nğŸ¯ PURPOSE:\nIntelligently merges existing state with new data using configurable strategies:\nâ€¢ Preserves existing data integrity\nâ€¢ Prevents accidental data loss\nâ€¢ Supports various merge patterns\nâ€¢ Maintains version history\nâ€¢ Enables conflict resolution\n\nğŸ”€ MERGE STRATEGIES:\n\nğŸ“Š DEEP MERGE (default):\nâ€¢ Recursively merges nested objects\nâ€¢ Preserves existing nested properties\nâ€¢ Adds new nested properties\nâ€¢ Ideal for complex state objects\n\nğŸƒ SHALLOW MERGE:\nâ€¢ Top-level property replacement\nâ€¢ Faster for simple updates\nâ€¢ Overwrites entire nested objects\nâ€¢ Good for performance-critical updates\n\nğŸ”„ REPLACE STRATEGY:\nâ€¢ Complete state replacement\nâ€¢ Ignores existing data\nâ€¢ Useful for reset operations\nâ€¢ Requires explicit confirmation\n\nğŸ“ APPEND STRATEGY:\nâ€¢ Combines arrays/lists\nâ€¢ Preserves existing list items\nâ€¢ Adds new items to end\nâ€¢ Perfect for activity logs\n\nğŸ“ˆ VERSION TRACKING:\nâ€¢ Increments version number\nâ€¢ Records update timestamp\nâ€¢ Tracks merge strategy used\nâ€¢ Enables audit trail\n\nğŸ” METADATA ENRICHMENT:\nâ€¢ lastUpdated timestamp\nâ€¢ version number incrementation\nâ€¢ updateStrategy recording\nâ€¢ userId and contextType preservation\n\nâœ… DATA INTEGRITY:\nâ€¢ Type validation before merge\nâ€¢ Circular reference detection\nâ€¢ Size limit enforcement\nâ€¢ Schema validation (optional)\n\nâ¡ï¸ NEXT STEPS:\nMerged â†’ Update Redis\nValidated â†’ Publish Event\nComplete â†’ Success Response"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.key }}",
        "value": "={{ $json.value }}",
        "expire": true,
        "ttl": "={{ $json.ttl }}"
      },
      "id": "f8a3b0c5-9d2e-4678-f901-23456789abcd",
      "name": "ğŸ”„ Update Redis State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1160, 1000],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "ğŸ”„ STATE UPDATE EXECUTOR\n\nğŸ¯ PURPOSE:\nUpdates Redis with merged state data maintaining consistency:\nâ€¢ Atomic state replacement\nâ€¢ TTL management for expiration\nâ€¢ Concurrent access safety\nâ€¢ Performance optimization\nâ€¢ Data integrity validation\n\nğŸ’¾ UPDATE PROCESS:\n1. Receives merged state from Merge State node\n2. Validates data structure and size\n3. Atomically replaces Redis key\n4. Sets appropriate TTL for expiration\n5. Confirms successful update\n\nâ° TTL MANAGEMENT:\nâ€¢ user context: 24 hours (86400s)\nâ€¢ learning context: 12 hours (43200s)\nâ€¢ session context: 4 hours (14400s)\nâ€¢ system context: 1 hour (3600s)\nâ€¢ Custom TTL: From request payload\n\nğŸ”’ CONSISTENCY GUARANTEES:\nâ€¢ Atomic operations prevent partial updates\nâ€¢ Optimistic concurrency control\nâ€¢ Version checking for conflicts\nâ€¢ Rollback capability on failures\n\nğŸ“Š PERFORMANCE FEATURES:\nâ€¢ Batch operations when possible\nâ€¢ Compression for large states\nâ€¢ Memory usage optimization\nâ€¢ Network efficiency\n\nâœ… VALIDATION CHECKS:\nâ€¢ JSON structure validation\nâ€¢ Size limit enforcement (1MB max)\nâ€¢ Key format verification\nâ€¢ Permission validation\n\nğŸ“ SUCCESS METRICS:\nâ€¢ Update latency measurement\nâ€¢ Success/failure rates\nâ€¢ Data size distribution\nâ€¢ TTL effectiveness analysis\n\nâŒ ERROR SCENARIOS:\nâ€¢ Redis connection failures â†’ Retry mechanism\nâ€¢ Memory limits exceeded â†’ Compression attempt\nâ€¢ Concurrent modifications â†’ Conflict resolution\nâ€¢ Invalid data format â†’ Sanitization\n\nâ¡ï¸ NEXT STEPS:\nSuccess â†’ Publish State Event\nFailure â†’ Error Handler\nComplete â†’ Format Response"
    }
  ],
  "connections": {
    "ğŸ“¥ State Manager Webhook": {
      "main": [
        [
          {
            "node": "âœ… Input Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "âœ… Input Validator": {
      "main": [
        [
          {
            "node": "ğŸ”€ Action Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "âŒ Error Response Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Action Router": {
      "main": [
        [
          {
            "node": "ğŸ” Get State from Redis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ’¾ Set State in Redis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ”„ Prepare State Update", 
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ğŸ—‘ï¸ Delete State from Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Get State from Redis": {
      "main": [
        [
          {
            "node": "ğŸ“¤ Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ’¾ Set State in Redis": {
      "main": [
        [
          {
            "node": "ğŸ“¡ Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Prepare State Update": {
      "main": [
        [
          {
            "node": "ğŸ” Get Existing State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ—‘ï¸ Delete State from Redis": {
      "main": [
        [
          {
            "node": "ğŸ“¡ Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ“¡ Publish State Event": {
      "main": [
        [
          {
            "node": "ğŸ“¤ Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ” Get Existing State": {
      "main": [
        [
          {
            "node": "ğŸ”€ Merge State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”€ Merge State": {
      "main": [
        [
          {
            "node": "ğŸ”„ Update Redis State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ”„ Update Redis State": {
      "main": [
        [
          {
            "node": "ğŸ“¡ Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-30T10:00:00.000Z",
      "updatedAt": "2025-01-30T10:00:00.000Z", 
      "id": "state-manager",
      "name": "state-manager"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-30T10:00:00.000Z",
  "versionId": "state-manager-v1"
}