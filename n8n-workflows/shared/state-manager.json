{
  "name": "🗃️ State Manager",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "state-manager",
        "responseMode": "lastNode",
        "responseData": "allEntries",
        "options": {}
      },
      "id": "f88ad8d7-4100-4c2f-b3e4-6f7a5e2c8d91",
      "name": "📥 State Manager Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [280, 400],
      "webhookId": "state-manager-webhook",
      "onError": "continueRegularOutput",
      "notes": "🚪 MAIN ENTRY POINT - State Manager Webhook\n\n🎯 PURPOSE:\nHandles all state management operations including:\n• User session creation/updates\n• Learning context persistence\n• Cross-workflow state synchronization\n• Context retrieval for other subsystems\n\n📝 EXPECTED PAYLOAD:\n{\n  \"action\": \"get|set|update|delete\",\n  \"userId\": \"string\",\n  \"sessionId\": \"string\", \n  \"contextType\": \"user|learning|system\",\n  \"data\": {},\n  \"ttl\": 3600\n}\n\n✅ SECURITY:\n• Validates user permissions\n• Sanitizes input data\n• Rate limiting applied\n• Audit logging enabled\n\n🔄 FLOW:\nWebhook → Input Validation → Action Router → State Operations → Response"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "required_fields_check",
              "leftValue": "={{ $json.action && $json.userId && $json.contextType }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equal"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "a7b2c9f4-8d1e-4567-a890-1234567890ab",
      "name": "✅ Input Validator",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [500, 400],
      "onError": "continueRegularOutput",
      "notes": "🔍 INPUT VALIDATION CHECKPOINT\n\n🎯 PURPOSE:\nValidates incoming requests have required fields:\n• action: Operation type (get/set/update/delete)\n• userId: Target user identifier\n• contextType: Type of context (user/learning/system)\n\n✅ VALIDATION RULES:\n• Required fields present\n• Action is valid operation\n• UserId format validation\n• ContextType enum validation\n• Data structure validation\n\n❌ FAILURE HANDLING:\n• Invalid requests → Error Response\n• Missing fields → 400 Bad Request\n• Malformed data → Sanitization attempt\n• Security violations → Alert & Block\n\n➡️ ROUTING:\nValid → Continue to Action Router\nInvalid → Error Response Node"
    },
    {
      "parameters": {
        "mode": "expression",
        "output1": "get_state",
        "output2": "set_state", 
        "output3": "update_state",
        "output4": "delete_state",
        "rules": {
          "rules": [
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "get",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "get_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "set", 
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "set_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "update",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "update_state"
            },
            {
              "conditions": [
                {
                  "leftValue": "={{ $json.action }}",
                  "rightValue": "delete",
                  "operator": {
                    "type": "string",
                    "operation": "equals"
                  }
                }
              ],
              "renameOutput": true,
              "outputKey": "delete_state"
            }
          ]
        },
        "options": {}
      },
      "id": "b8c3d0e5-9f2a-4678-b901-234567890bcd",
      "name": "🔀 Action Router",
      "type": "n8n-nodes-base.switch", 
      "typeVersion": 3,
      "position": [720, 400],
      "onError": "continueRegularOutput",
      "notes": "🚦 ACTION ROUTING HUB\n\n🎯 PURPOSE:\nRoutes validated requests to appropriate state operations:\n• GET → Retrieve existing state data\n• SET → Create new state entries\n• UPDATE → Modify existing state data\n• DELETE → Remove state entries\n\n📊 ROUTING LOGIC:\nAnalyzes 'action' field and directs to specialized handlers:\n\n🔍 GET Operations:\n• User profile retrieval\n• Learning progress queries\n• Session context lookup\n• Cross-workflow state access\n\n💾 SET Operations:\n• New user session creation\n• Initial context establishment\n• First-time state initialization\n• Workflow registration\n\n🔄 UPDATE Operations:\n• Learning progress updates\n• Session data modifications\n• Context synchronization\n• Performance metric updates\n\n🗑️ DELETE Operations:\n• Session cleanup\n• Context expiration\n• User data removal (GDPR)\n• Temporary state clearing\n\n➡️ OUTPUT PORTS:\nget_state | set_state | update_state | delete_state"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "stateData",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}",
        "keyType": "automatic"
      },
      "id": "c9d4e1f6-0a3b-5789-c012-34567890cdef",
      "name": "🔍 Get State from Redis",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [940, 200],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "📥 STATE RETRIEVAL ENGINE\n\n🎯 PURPOSE:\nRetrieves user state data from Redis cache:\n• User profiles and preferences\n• Learning progress and context\n• Session data and activity\n• Cross-workflow shared state\n\n🔑 KEY STRUCTURE:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\nExamples:\n• user_state:user123:learning:session456\n• user_state:user123:profile\n• user_state:user123:system:workflow789\n\n📊 CONTEXT TYPES:\n• user: Profile, preferences, settings\n• learning: Progress, current module, achievements\n• system: Workflow state, error context, metrics\n• session: Temporary interaction data\n\n✅ FEATURES:\n• Automatic key type detection\n• JSON deserialization\n• Cache hit/miss tracking\n• Performance monitoring\n\n❌ ERROR HANDLING:\n• Key not found → Default empty state\n• Redis connection issues → Fallback to DB\n• Malformed data → Log error & return empty\n• Permission denied → Access control response\n\n➡️ NEXT STEPS:\nFound → Format Response\nNot Found → Default State Response"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}",
        "value": "={{ JSON.stringify($json.data) }}",
        "expire": true,
        "ttl": "={{ $json.ttl || 3600 }}"
      },
      "id": "d0e5f2a7-1b4c-6890-d123-45678901defa",
      "name": "💾 Set State in Redis", 
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [940, 400],
      "credentials": {
        "redis": {
          "id": "redis-credentials", 
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "💾 STATE STORAGE ENGINE\n\n🎯 PURPOSE:\nStores new state data in Redis with TTL management:\n• Creates new user sessions\n• Initializes learning contexts\n• Establishes workflow state\n• Manages temporary data\n\n🔑 KEY STRATEGY:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\n⏰ TTL MANAGEMENT:\n• Default: 1 hour (3600s)\n• User sessions: 4 hours\n• Learning context: 24 hours\n• System state: 1 hour\n• Custom TTL via request payload\n\n📦 DATA HANDLING:\n• JSON serialization of complex objects\n• Validates data structure before storage\n• Compresses large payloads automatically\n• Maintains data integrity checks\n\n✅ STORAGE FEATURES:\n• Atomic operations\n• Expiration management\n• Memory optimization\n• Concurrent access safety\n\n📊 MONITORING:\n• Storage success/failure rates\n• Memory usage tracking\n• Key expiration analytics\n• Performance metrics\n\n➡️ NEXT STEPS:\nSuccess → Confirmation Response\nFailure → Error Handling & Retry"
    },
    {
      "parameters": {
        "jsCode": "// 🔄 STATE UPDATE PROCESSOR\n// Handles intelligent merging of existing state with new data\n\nconst existingKey = 'user_state:' + items[0].json.userId + ':' + items[0].json.contextType + (items[0].json.sessionId ? ':' + items[0].json.sessionId : '');\nconst newData = items[0].json.data || {};\nconst mergeStrategy = items[0].json.mergeStrategy || 'deep';\nconst timestamp = new Date().toISOString();\n\n// First, we need to get existing state\n// This will be handled by a Redis GET operation before this node\n\n// For now, prepare the update data\nconst updatePayload = {\n  key: existingKey,\n  newData: newData,\n  mergeStrategy: mergeStrategy,\n  timestamp: timestamp,\n  userId: items[0].json.userId,\n  contextType: items[0].json.contextType,\n  sessionId: items[0].json.sessionId,\n  ttl: items[0].json.ttl || 3600\n};\n\n// Add metadata for tracking\nupdatePayload.metadata = {\n  operation: 'update',\n  requestId: items[0].json.requestId || 'req_' + Date.now(),\n  source: items[0].json.source || 'state-manager',\n  version: '1.0'\n};\n\nreturn [updatePayload];"
      },
      "id": "e1f6a3b8-2c5d-7901-e234-56789012efab",
      "name": "🔄 Prepare State Update",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 600],
      "onError": "continueRegularOutput", 
      "notes": "🔄 STATE UPDATE PREPARATION\n\n🎯 PURPOSE:\nPrepares intelligent state updates with merge strategies:\n• Deep merge for complex objects\n• Shallow merge for simple updates\n• Array append/replace operations\n• Timestamp tracking and versioning\n\n🔀 MERGE STRATEGIES:\n• deep: Recursive object merging (default)\n• shallow: Top-level property replacement\n• replace: Complete state replacement\n• append: Add to existing arrays\n• increment: Numeric value updates\n\n📊 UPDATE TYPES:\n• Learning progress increments\n• Session data modifications\n• User preference updates\n• Workflow state changes\n• Performance metric updates\n\n🕒 VERSIONING:\n• Timestamp all updates\n• Track change history\n• Maintain audit trail\n• Enable rollback capability\n\n✅ FEATURES:\n• Conflict resolution\n• Data validation before merge\n• Type safety enforcement\n• Metadata enrichment\n\n📝 METADATA:\n• RequestId for tracing\n• Source system identification\n• Operation type logging\n• Version tracking\n\n➡️ NEXT STEPS:\nPrepared → Get Existing State\nMerged → Update Redis\nValidated → Success Response"
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ 'user_state:' + $json.userId + ':' + $json.contextType + ($json.sessionId ? ':' + $json.sessionId : '') }}"
      },
      "id": "f2a7b4c9-3d6e-8012-f345-67890123fabc",
      "name": "🗑️ Delete State from Redis",
      "type": "n8n-nodes-base.redis", 
      "typeVersion": 1,
      "position": [940, 800],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "🗑️ STATE DELETION ENGINE\n\n🎯 PURPOSE:\nSafely removes state data from Redis cache:\n• Session cleanup after logout\n• Expired context removal\n• GDPR compliance deletions\n• Temporary state clearing\n• System maintenance cleanup\n\n🔑 DELETION SCOPE:\nTargets specific keys matching pattern:\nuser_state:{userId}:{contextType}[:{sessionId}]\n\n🛡️ SAFETY MEASURES:\n• Confirmation before critical deletions\n• Backup critical data before removal\n• Audit logging for all deletions\n• Permission validation\n• Cascading delete prevention\n\n📊 DELETION TYPES:\n• Session cleanup (automatic)\n• User-requested removal\n• System maintenance\n• Privacy compliance (GDPR)\n• Error state clearing\n\n✅ VERIFICATION:\n• Confirms key existence before deletion\n• Validates user permissions\n• Logs deletion operations\n• Returns deletion confirmation\n\n⚠️ CRITICAL CONTEXTS:\n• learning: Check for unsaved progress\n• profile: Require explicit confirmation\n• system: Validate admin permissions\n• session: Safe for automatic cleanup\n\n📝 AUDIT TRAIL:\n• Deletion timestamp\n• Requesting user/system\n• Deletion reason\n• Recovery information\n\n➡️ NEXT STEPS:\nDeleted → Confirmation Response\nFailed → Error Response\nBlocked → Permission Denied"
    },
    {
      "parameters": {
        "jsCode": "// 📤 STATE RESPONSE FORMATTER\n// Standardizes all state manager responses\n\nconst inputData = items[0].json;\nconst operation = inputData.operation || $node['Action Router'].json.action || 'unknown';\nconst success = !inputData.error;\nconst timestamp = new Date().toISOString();\n\n// Base response structure\nlet response = {\n  success: success,\n  operation: operation,\n  timestamp: timestamp,\n  userId: inputData.userId,\n  contextType: inputData.contextType,\n  sessionId: inputData.sessionId || null\n};\n\n// Add operation-specific data\nswitch(operation) {\n  case 'get':\n    response.data = inputData.data || null;\n    response.found = !!inputData.data;\n    response.cacheHit = true;\n    break;\n    \n  case 'set':\n    response.created = success;\n    response.ttl = inputData.ttl || 3600;\n    response.key = inputData.key;\n    break;\n    \n  case 'update':\n    response.updated = success;\n    response.changes = inputData.changes || {};\n    response.version = inputData.version || '1.0';\n    break;\n    \n  case 'delete':\n    response.deleted = success;\n    response.key = inputData.key;\n    break;\n    \n  default:\n    response.message = 'Unknown operation';\n}\n\n// Add metadata\nresponse.metadata = {\n  requestId: inputData.requestId || 'req_' + Date.now(),\n  processingTime: Date.now() - (inputData.startTime || Date.now()),\n  workflow: 'state-manager',\n  version: '1.0'\n};\n\n// Add error details if present\nif (!success && inputData.error) {\n  response.error = {\n    code: inputData.error.code || 'UNKNOWN_ERROR',\n    message: inputData.error.message || 'An error occurred',\n    details: inputData.error.details || {}\n  };\n}\n\nreturn [response];"
      },
      "id": "a3b8c5d0-4e7f-9123-a456-78901234bcde",
      "name": "📤 Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1160, 400],
      "onError": "continueRegularOutput",
      "notes": "📤 RESPONSE FORMATTING ENGINE\n\n🎯 PURPOSE:\nStandardizes all State Manager responses across operations:\n• Uniform response structure\n• Operation-specific data inclusion\n• Error handling and messaging\n• Performance metrics embedding\n• Audit trail information\n\n📋 RESPONSE STRUCTURE:\n{\n  \"success\": boolean,\n  \"operation\": \"get|set|update|delete\",\n  \"timestamp\": \"ISO string\",\n  \"userId\": \"string\",\n  \"contextType\": \"user|learning|system\",\n  \"data\": {}, // Operation-specific\n  \"metadata\": {}\n}\n\n🔍 GET RESPONSES:\n• data: Retrieved state object\n• found: Boolean existence flag\n• cacheHit: Performance indicator\n\n💾 SET RESPONSES:\n• created: Success confirmation\n• ttl: Expiration time set\n• key: Redis key created\n\n🔄 UPDATE RESPONSES:\n• updated: Modification success\n• changes: Applied changes summary\n• version: State version number\n\n🗑️ DELETE RESPONSES:\n• deleted: Removal confirmation\n• key: Deleted Redis key\n\n📊 METADATA INCLUDED:\n• requestId: Unique request identifier\n• processingTime: Operation duration\n• workflow: Source workflow name\n• version: Response format version\n\n➡️ FINAL OUTPUT:\nStandardized JSON response for all operations"
    },
    {
      "parameters": {
        "jsCode": "// ❌ ERROR RESPONSE HANDLER\n// Generates standardized error responses for failed operations\n\nconst error = items[0].json.error || {};\nconst originalRequest = items[0].json;\nconst timestamp = new Date().toISOString();\n\n// Standard error response structure\nconst errorResponse = {\n  success: false,\n  operation: originalRequest.action || 'unknown',\n  timestamp: timestamp,\n  userId: originalRequest.userId || null,\n  contextType: originalRequest.contextType || null,\n  sessionId: originalRequest.sessionId || null,\n  error: {\n    code: error.code || 'VALIDATION_ERROR',\n    message: error.message || 'Request validation failed',\n    details: error.details || {\n      missingFields: [],\n      invalidFields: [],\n      suggestions: []\n    }\n  },\n  metadata: {\n    requestId: originalRequest.requestId || 'req_' + Date.now(),\n    workflow: 'state-manager',\n    errorTimestamp: timestamp,\n    version: '1.0'\n  }\n};\n\n// Add specific error details based on validation failure\nif (!originalRequest.action) {\n  errorResponse.error.details.missingFields.push('action');\n  errorResponse.error.details.suggestions.push('Include action field: get, set, update, or delete');\n}\n\nif (!originalRequest.userId) {\n  errorResponse.error.details.missingFields.push('userId');\n  errorResponse.error.details.suggestions.push('Include userId field with valid user identifier');\n}\n\nif (!originalRequest.contextType) {\n  errorResponse.error.details.missingFields.push('contextType');\n  errorResponse.error.details.suggestions.push('Include contextType: user, learning, or system');\n}\n\nreturn [errorResponse];"
      },
      "id": "b4c9d6e1-5f8a-0234-b567-89012345cdef",
      "name": "❌ Error Response Handler",
      "type": "n8n-nodes-base.code", 
      "typeVersion": 2,
      "position": [720, 600],
      "onError": "continueRegularOutput",
      "notes": "❌ ERROR RESPONSE GENERATOR\n\n🎯 PURPOSE:\nGenerates standardized error responses for validation failures:\n• Missing required fields\n• Invalid operation types\n• Malformed request data\n• Authentication failures\n• Permission violations\n\n📋 ERROR RESPONSE STRUCTURE:\n{\n  \"success\": false,\n  \"operation\": \"attempted_operation\",\n  \"timestamp\": \"ISO_string\", \n  \"error\": {\n    \"code\": \"ERROR_CODE\",\n    \"message\": \"Human readable message\",\n    \"details\": {\n      \"missingFields\": [],\n      \"invalidFields\": [],\n      \"suggestions\": []\n    }\n  }\n}\n\n🔍 ERROR CATEGORIES:\n• VALIDATION_ERROR: Missing/invalid fields\n• PERMISSION_DENIED: Access control failures\n• RATE_LIMITED: Too many requests\n• SYSTEM_ERROR: Internal failures\n• NOT_FOUND: Resource doesn't exist\n\n📝 DETAILED FEEDBACK:\n• Lists specific missing fields\n• Identifies invalid field values\n• Provides actionable suggestions\n• Includes example correct formats\n\n🛡️ SECURITY FEATURES:\n• Sanitizes error messages\n• Prevents information leakage\n• Logs security violations\n• Rate limiting violation tracking\n\n📊 ERROR ANALYTICS:\n• Error frequency tracking\n• Common failure patterns\n• Client error distribution\n• Performance impact metrics\n\n➡️ FINAL OUTPUT:\nStandardized error response with helpful debugging information"
    },
    {
      "parameters": {
        "operation": "publish",
        "channel": "state_events",
        "messageData": "={{ JSON.stringify({\n  event: 'state_changed',\n  userId: $json.userId,\n  contextType: $json.contextType,\n  sessionId: $json.sessionId,\n  operation: $json.operation,\n  timestamp: new Date().toISOString(),\n  source: 'state-manager'\n}) }}"
      },
      "id": "c5d0e7f2-6a9b-1345-c678-90123456defa",
      "name": "📡 Publish State Event",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1160, 600],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "📡 STATE EVENT BROADCASTER\n\n🎯 PURPOSE:\nBroadcasts state changes to other subsystems via Redis pub/sub:\n• Knowledge Engine context updates\n• Scheduler behavior adaptations\n• Analytics pattern tracking\n• Real-time dashboard updates\n• Cross-workflow synchronization\n\n📺 CHANNEL: state_events\nAll subsystems subscribe to receive notifications\n\n📦 EVENT PAYLOAD:\n{\n  \"event\": \"state_changed\",\n  \"userId\": \"string\",\n  \"contextType\": \"user|learning|system\",\n  \"sessionId\": \"string|null\",\n  \"operation\": \"get|set|update|delete\",\n  \"timestamp\": \"ISO_string\",\n  \"source\": \"state-manager\"\n}\n\n🎧 SUBSCRIBERS:\n• Knowledge Engine: Updates user context for better responses\n• Daily Scheduler: Adapts recommendations based on state changes\n• Analytics System: Tracks user behavior patterns\n• Master Orchestrator: Maintains global system state\n• Error Handler: Context for error resolution\n\n🚀 REAL-TIME BENEFITS:\n• Instant cross-system synchronization\n• Reduced database polling\n• Event-driven architecture\n• Decoupled system communication\n• Scalable message distribution\n\n📊 EVENT TYPES:\n• User login/logout state changes\n• Learning progress updates\n• Preference modifications\n• Session creation/expiration\n• System state transitions\n\n⚡ PERFORMANCE:\n• Async non-blocking publish\n• Minimal payload for speed\n• Reliable delivery guarantee\n• Channel-based routing\n\n➡️ NEXT STEPS:\nEvent Published → Continue Processing\nFailed Publish → Log Error (Non-blocking)"
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "existingData",
        "key": "={{ $json.key }}",
        "keyType": "automatic"
      },
      "id": "d6e1f8a3-7b0c-2456-d789-01234567efab",
      "name": "🔍 Get Existing State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [720, 800],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "🔍 EXISTING STATE RETRIEVAL\n\n🎯 PURPOSE:\nRetrieves current state data before updates for intelligent merging:\n• Prevents data loss during updates\n• Enables conflict resolution\n• Supports incremental changes\n• Maintains data consistency\n• Enables rollback capabilities\n\n🔗 UPDATE FLOW:\n1. Get current state (this node)\n2. Merge with new data (Merge State)\n3. Save updated state (Update Redis)\n4. Publish change event\n5. Return confirmation\n\n📊 MERGE STRATEGIES SUPPORTED:\n• deep: Recursive object merging\n• shallow: Top-level property replacement\n• replace: Complete state replacement\n• append: Array/list additions\n• increment: Numeric modifications\n\n✅ DATA SAFETY:\n• Atomic read operations\n• Consistent state snapshots\n• Version conflict detection\n• Concurrent access handling\n\n🔄 HANDLING SCENARIOS:\n• State exists: Proceed with merge\n• State missing: Create new state\n• State corrupted: Initialize default\n• Permission denied: Error response\n\n📝 TRACKING:\n• Read operation metrics\n• Cache hit/miss rates\n• Data consistency checks\n• Performance monitoring\n\n➡️ NEXT STEPS:\nFound → Merge State\nNot Found → Create New State\nError → Error Handler"
    },
    {
      "parameters": {
        "jsCode": "// 🔀 STATE MERGE PROCESSOR\n// Intelligently merges existing state with new data\n\nconst existingState = items[0].json.existingData ? JSON.parse(items[0].json.existingData) : {};\nconst newData = items[0].json.newData || {};\nconst mergeStrategy = items[0].json.mergeStrategy || 'deep';\nconst userId = items[0].json.userId;\nconst contextType = items[0].json.contextType;\nconst sessionId = items[0].json.sessionId;\nconst ttl = items[0].json.ttl;\nconst timestamp = new Date().toISOString();\n\n// Deep merge function\nfunction deepMerge(target, source) {\n  const output = Object.assign({}, target);\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isObject(source[key])) {\n        if (!(key in target))\n          Object.assign(output, { [key]: source[key] });\n        else\n          output[key] = deepMerge(target[key], source[key]);\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n  return output;\n}\n\nfunction isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item));\n}\n\n// Apply merge strategy\nlet mergedState;\nswitch(mergeStrategy) {\n  case 'deep':\n    mergedState = deepMerge(existingState, newData);\n    break;\n  case 'shallow':\n    mergedState = Object.assign({}, existingState, newData);\n    break;\n  case 'replace':\n    mergedState = newData;\n    break;\n  case 'append':\n    mergedState = existingState;\n    Object.keys(newData).forEach(key => {\n      if (Array.isArray(existingState[key]) && Array.isArray(newData[key])) {\n        mergedState[key] = [...existingState[key], ...newData[key]];\n      } else {\n        mergedState[key] = newData[key];\n      }\n    });\n    break;\n  default:\n    mergedState = deepMerge(existingState, newData);\n}\n\n// Add metadata\nmergedState._metadata = {\n  lastUpdated: timestamp,\n  version: (existingState._metadata?.version || 0) + 1,\n  updateStrategy: mergeStrategy,\n  userId: userId,\n  contextType: contextType\n};\n\n// Prepare for Redis update\nconst result = {\n  key: 'user_state:' + userId + ':' + contextType + (sessionId ? ':' + sessionId : ''),\n  value: JSON.stringify(mergedState),\n  ttl: ttl || 3600,\n  mergedState: mergedState,\n  operation: 'update',\n  userId: userId,\n  contextType: contextType,\n  sessionId: sessionId,\n  changes: {\n    added: Object.keys(newData),\n    strategy: mergeStrategy,\n    version: mergedState._metadata.version\n  }\n};\n\nreturn [result];"
      },
      "id": "e7f2a9b4-8c1d-3567-e890-12345678fabc",
      "name": "🔀 Merge State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 1000],
      "onError": "continueRegularOutput",
      "notes": "🔀 INTELLIGENT STATE MERGER\n\n🎯 PURPOSE:\nIntelligently merges existing state with new data using configurable strategies:\n• Preserves existing data integrity\n• Prevents accidental data loss\n• Supports various merge patterns\n• Maintains version history\n• Enables conflict resolution\n\n🔀 MERGE STRATEGIES:\n\n📊 DEEP MERGE (default):\n• Recursively merges nested objects\n• Preserves existing nested properties\n• Adds new nested properties\n• Ideal for complex state objects\n\n🏃 SHALLOW MERGE:\n• Top-level property replacement\n• Faster for simple updates\n• Overwrites entire nested objects\n• Good for performance-critical updates\n\n🔄 REPLACE STRATEGY:\n• Complete state replacement\n• Ignores existing data\n• Useful for reset operations\n• Requires explicit confirmation\n\n📝 APPEND STRATEGY:\n• Combines arrays/lists\n• Preserves existing list items\n• Adds new items to end\n• Perfect for activity logs\n\n📈 VERSION TRACKING:\n• Increments version number\n• Records update timestamp\n• Tracks merge strategy used\n• Enables audit trail\n\n🔍 METADATA ENRICHMENT:\n• lastUpdated timestamp\n• version number incrementation\n• updateStrategy recording\n• userId and contextType preservation\n\n✅ DATA INTEGRITY:\n• Type validation before merge\n• Circular reference detection\n• Size limit enforcement\n• Schema validation (optional)\n\n➡️ NEXT STEPS:\nMerged → Update Redis\nValidated → Publish Event\nComplete → Success Response"
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.key }}",
        "value": "={{ $json.value }}",
        "expire": true,
        "ttl": "={{ $json.ttl }}"
      },
      "id": "f8a3b0c5-9d2e-4678-f901-23456789abcd",
      "name": "🔄 Update Redis State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1160, 1000],
      "credentials": {
        "redis": {
          "id": "redis-credentials",
          "name": "Redis Credentials"
        }
      },
      "onError": "continueRegularOutput",
      "notes": "🔄 STATE UPDATE EXECUTOR\n\n🎯 PURPOSE:\nUpdates Redis with merged state data maintaining consistency:\n• Atomic state replacement\n• TTL management for expiration\n• Concurrent access safety\n• Performance optimization\n• Data integrity validation\n\n💾 UPDATE PROCESS:\n1. Receives merged state from Merge State node\n2. Validates data structure and size\n3. Atomically replaces Redis key\n4. Sets appropriate TTL for expiration\n5. Confirms successful update\n\n⏰ TTL MANAGEMENT:\n• user context: 24 hours (86400s)\n• learning context: 12 hours (43200s)\n• session context: 4 hours (14400s)\n• system context: 1 hour (3600s)\n• Custom TTL: From request payload\n\n🔒 CONSISTENCY GUARANTEES:\n• Atomic operations prevent partial updates\n• Optimistic concurrency control\n• Version checking for conflicts\n• Rollback capability on failures\n\n📊 PERFORMANCE FEATURES:\n• Batch operations when possible\n• Compression for large states\n• Memory usage optimization\n• Network efficiency\n\n✅ VALIDATION CHECKS:\n• JSON structure validation\n• Size limit enforcement (1MB max)\n• Key format verification\n• Permission validation\n\n📝 SUCCESS METRICS:\n• Update latency measurement\n• Success/failure rates\n• Data size distribution\n• TTL effectiveness analysis\n\n❌ ERROR SCENARIOS:\n• Redis connection failures → Retry mechanism\n• Memory limits exceeded → Compression attempt\n• Concurrent modifications → Conflict resolution\n• Invalid data format → Sanitization\n\n➡️ NEXT STEPS:\nSuccess → Publish State Event\nFailure → Error Handler\nComplete → Format Response"
    }
  ],
  "connections": {
    "📥 State Manager Webhook": {
      "main": [
        [
          {
            "node": "✅ Input Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "✅ Input Validator": {
      "main": [
        [
          {
            "node": "🔀 Action Router",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "❌ Error Response Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔀 Action Router": {
      "main": [
        [
          {
            "node": "🔍 Get State from Redis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "💾 Set State in Redis",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "🔄 Prepare State Update", 
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "🗑️ Delete State from Redis",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔍 Get State from Redis": {
      "main": [
        [
          {
            "node": "📤 Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "💾 Set State in Redis": {
      "main": [
        [
          {
            "node": "📡 Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔄 Prepare State Update": {
      "main": [
        [
          {
            "node": "🔍 Get Existing State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🗑️ Delete State from Redis": {
      "main": [
        [
          {
            "node": "📡 Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "📡 Publish State Event": {
      "main": [
        [
          {
            "node": "📤 Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔍 Get Existing State": {
      "main": [
        [
          {
            "node": "🔀 Merge State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔀 Merge State": {
      "main": [
        [
          {
            "node": "🔄 Update Redis State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "🔄 Update Redis State": {
      "main": [
        [
          {
            "node": "📡 Publish State Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-30T10:00:00.000Z",
      "updatedAt": "2025-01-30T10:00:00.000Z", 
      "id": "state-manager",
      "name": "state-manager"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-30T10:00:00.000Z",
  "versionId": "state-manager-v1"
}