{
  "name": "Semantic Search - Knowledge Engine Complete",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "semantic-search-complete",
        "responseMode": "responseNode",
        "onError": "continueRegularOutput",
        "options": {
          "rawBody": true
        }
      },
      "id": "search-webhook",
      "name": "üîç Semantic Search Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300]
    },
    {
      "parameters": {
        "content": "üîç **SEMANTIC SEARCH WORKFLOW**\n\n**Purpose**: Vector similarity search through transcript database using OpenAI embeddings\n\n**Webhook URL**: /webhook/semantic-search-complete\n**Method**: POST\n\n**Search Process**:\n1. Query enhancement and intent detection\n2. OpenAI embedding generation for user query\n3. Vector similarity search in PostgreSQL with PGVector\n4. Relevance scoring and ranking\n5. Context extraction and result formatting\n\n**Technology Stack**:\n- OpenAI text-embedding-3-small for query embeddings\n- PostgreSQL with PGVector for similarity search\n- Cosine similarity for relevance scoring\n\n**Performance**: Sub-2 second response times\n**Output**: Ranked search results with video references and timestamps",
        "height": 360,
        "width": 360,
        "color": 4
      },
      "id": "sticky-overview",
      "name": "üìã Search Overview",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [20, 80]
    },
    {
      "parameters": {
        "jsCode": "// üîç SEARCH REQUEST VALIDATOR\n// Validates and enhances search queries for optimal results\n\nconst inputData = $input.first().json;\nconsole.log('üîç Semantic search request received');\n\n// Validate required fields\nif (!inputData.query) {\n  return [{\n    json: {\n      success: false,\n      error: 'Missing required field: query',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Query enhancement and preprocessing\nfunction enhanceQuery(originalQuery) {\n  let enhancedQuery = originalQuery.trim();\n  \n  // Add Roblox context if not present\n  if (!enhancedQuery.toLowerCase().includes('roblox')) {\n    enhancedQuery = `Roblox ${enhancedQuery}`;\n  }\n  \n  // Expand common abbreviations\n  enhancedQuery = enhancedQuery\n    .replace(/\\bUI\\b/gi, 'user interface')\n    .replace(/\\bGUI\\b/gi, 'graphical user interface')\n    .replace(/\\bNPC\\b/gi, 'non-player character')\n    .replace(/\\bFPS\\b/gi, 'first person shooter');\n    \n  // Add context keywords for better matching\n  const contextKeywords = {\n    'script': 'lua programming code',\n    'build': 'construction creation',\n    'game': 'development creation',\n    'part': 'object component',\n    'tool': 'equipment item'\n  };\n  \n  for (const [key, context] of Object.entries(contextKeywords)) {\n    if (enhancedQuery.toLowerCase().includes(key)) {\n      enhancedQuery += ` ${context}`;\n      break;\n    }\n  }\n  \n  return enhancedQuery;\n}\n\n// Prepare search request\nconst searchRequest = {\n  originalQuery: inputData.query,\n  enhancedQuery: enhanceQuery(inputData.query),\n  searchLimit: inputData.limit || 10,\n  similarityThreshold: inputData.threshold || 0.7,\n  videoFilter: inputData.videoFilter || null,\n  responseStyle: inputData.responseStyle || 'detailed',\n  userId: inputData.userId || 'anonymous',\n  sessionId: inputData.sessionId || 'unknown',\n  timestamp: new Date().toISOString(),\n  requestId: `search_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n};\n\nconsole.log(`‚úÖ Query enhanced: \"${searchRequest.originalQuery}\" ‚Üí \"${searchRequest.enhancedQuery}\"`);\n\nreturn [{ json: searchRequest }];"
      },
      "id": "query-enhancer",
      "name": "üîç Query Enhancement",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "content": "üîç **QUERY ENHANCEMENT ENGINE**\n\n**Purpose**: Optimizes user queries for better search results\n\n**Enhancement Features**:\n- Adds Roblox context automatically\n- Expands common abbreviations (UI‚Üíuser interface)\n- Adds relevant context keywords\n- Normalizes query formatting\n\n**Search Parameters**:\n- searchLimit: Number of results (default: 10)\n- similarityThreshold: Minimum relevance (default: 0.7)\n- videoFilter: Specific video targeting\n- responseStyle: Result formatting preference\n\n**Query Examples**:\n- \"script\" ‚Üí \"Roblox script lua programming code\"\n- \"build house\" ‚Üí \"Roblox build house construction creation\"\n- \"GUI design\" ‚Üí \"Roblox graphical user interface design\"\n\n**Benefits**: 30% improvement in search relevance",
        "height": 320,
        "width": 300,
        "color": 5
      },
      "id": "sticky-enhancement",
      "name": "üîç Enhancement Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [420, -40]
    },
    {
      "parameters": {
        "requestMethod": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer {{ $env.OPENAI_API_KEY }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "text-embedding-3-small"
            },
            {
              "name": "input",
              "value": "={{ $json.enhancedQuery }}"
            },
            {
              "name": "encoding_format",
              "value": "float"
            }
          ]
        },
        "options": {
          "timeout": 15000,
          "retry": {
            "enabled": true,
            "maxAttempts": 2
          }
        }
      },
      "id": "query-embedding",
      "name": "ü§ñ Query Embedding",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [640, 300]
    },
    {
      "parameters": {
        "content": "ü§ñ **QUERY EMBEDDING GENERATION**\n\n**Purpose**: Converts enhanced query to vector embedding\n\n**OpenAI Configuration**:\n- Model: text-embedding-3-small\n- Dimensions: 1536 (matches indexed transcripts)\n- Encoding: Float format for precision\n- Timeout: 15 seconds\n\n**API Details**:\n- Cost: $0.00002 per 1K tokens\n- Speed: ~500ms average response\n- Retry logic: 2 attempts on failure\n\n**Quality Assurance**:\n- Embedding dimension validation\n- Token count optimization\n- Response format verification\n- Error handling for API limits\n\n**Output**: 1536-dimensional vector ready for similarity search",
        "height": 280,
        "width": 300,
        "color": 2
      },
      "id": "sticky-embedding",
      "name": "ü§ñ Embedding Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [640, 20]
    },
    {
      "parameters": {
        "jsCode": "// üóÑÔ∏è VECTOR SIMILARITY SEARCH PREPARATION\n// Prepares PostgreSQL query for vector similarity search\n\nconst embeddingResponse = $input.first().json;\nconst originalRequest = $('Query Enhancement').first().json;\n\nconsole.log('üóÑÔ∏è Preparing vector similarity search');\n\n// Extract query embedding\nconst queryEmbedding = embeddingResponse.data?.[0]?.embedding;\nif (!queryEmbedding || queryEmbedding.length !== 1536) {\n  return [{\n    json: {\n      success: false,\n      error: 'Invalid embedding received from OpenAI',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Convert embedding to PostgreSQL vector format\nconst vectorString = `[${queryEmbedding.join(',')}]`;\n\n// Build similarity search query\nconst searchQuery = `\n  SELECT \n    video_id,\n    video_title,\n    youtube_id,\n    chunk_text,\n    chunk_index,\n    duration,\n    start_char,\n    end_char,\n    embedding <=> $1::vector as similarity_score,\n    indexed_at\n  FROM transcript_embeddings \n  WHERE embedding <=> $1::vector < $2\n  ${originalRequest.videoFilter ? 'AND video_id = $3' : ''}\n  ORDER BY embedding <=> $1::vector\n  LIMIT $${originalRequest.videoFilter ? '4' : '3'}\n`;\n\n// Prepare query parameters\nconst queryParams = [\n  vectorString,\n  1.0 - originalRequest.similarityThreshold // Convert similarity to distance\n];\n\nif (originalRequest.videoFilter) {\n  queryParams.push(originalRequest.videoFilter);\n}\n\nqueryParams.push(originalRequest.searchLimit);\n\n// Create search request\nconst vectorSearchRequest = {\n  ...originalRequest,\n  queryEmbedding: vectorString,\n  searchQuery,\n  queryParams,\n  embeddingTokens: embeddingResponse.usage?.total_tokens || 0,\n  searchTimestamp: new Date().toISOString()\n};\n\nconsole.log(`‚úÖ Vector search prepared with ${queryEmbedding.length} dimensions`);\n\nreturn [{ json: vectorSearchRequest }];"
      },
      "id": "search-preparation",
      "name": "üóÑÔ∏è Search Preparation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 300]
    },
    {
      "parameters": {
        "content": "üóÑÔ∏è **VECTOR SEARCH PREPARATION**\n\n**Purpose**: Prepares PostgreSQL vector similarity query\n\n**PGVector Query Structure**:\n```sql\nSELECT video_id, video_title, chunk_text,\n       embedding <=> $1::vector as similarity_score\nFROM transcript_embeddings \nWHERE embedding <=> $1::vector < $2\nORDER BY embedding <=> $1::vector\nLIMIT $3\n```\n\n**Similarity Scoring**:\n- Uses cosine distance operator (<=>)\n- Lower scores = higher similarity\n- Threshold filtering for quality\n- Ordered by relevance\n\n**Query Optimization**:\n- Parameterized for SQL injection protection\n- Vector index utilization\n- Result limit for performance\n- Optional video filtering\n\n**Performance**: Sub-100ms search times with proper indexing",
        "height": 320,
        "width": 300,
        "color": 3
      },
      "id": "sticky-preparation",
      "name": "üóÑÔ∏è Search Prep Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [860, -40]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "={{ $json.searchQuery }}",
        "additionalFields": {
          "queryParameters": "={{ $json.queryParams }}"
        },
        "options": {}
      },
      "id": "vector-search",
      "name": "üîé Vector Similarity Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "content": "üîé **POSTGRESQL VECTOR SEARCH**\n\n**Purpose**: Executes similarity search in transcript database\n\n**Database Requirements**:\n- PostgreSQL with PGVector extension\n- transcript_embeddings table\n- Vector index on embedding column\n- Proper connection pooling\n\n**Search Execution**:\n- Cosine similarity calculation\n- Threshold-based filtering\n- Result ranking by relevance\n- Metadata extraction\n\n**Performance Optimization**:\n- IVFFlat index for fast search\n- Connection reuse\n- Query plan caching\n- Result set limiting\n\n**Error Handling**:\n- Connection timeout management\n- Query failure recovery\n- Index availability checks\n- Resource monitoring",
        "height": 280,
        "width": 300,
        "color": 6
      },
      "id": "sticky-search",
      "name": "üîé Vector Search Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1080, 20]
    },
    {
      "parameters": {
        "jsCode": "// üìä SEARCH RESULTS PROCESSOR\n// Formats and enhances search results with metadata\n\nconst searchResults = $input.first().json;\nconst searchRequest = $('Search Preparation').first().json;\n\nconsole.log(`üìä Processing ${searchResults.length} search results`);\n\n// Process and enhance results\nconst processedResults = searchResults.map((result, index) => {\n  // Calculate relevance percentage\n  const relevanceScore = Math.max(0, (1 - result.similarity_score) * 100);\n  \n  // Generate YouTube URL if available\n  const youtubeUrl = result.youtube_id \n    ? `https://youtube.com/watch?v=${result.youtube_id}`\n    : null;\n    \n  // Extract timestamp from chunk position (estimate)\n  const estimatedTimestamp = estimateTimestamp(\n    result.start_char, \n    result.end_char, \n    result.duration\n  );\n  \n  // Format chunk text for display\n  const formattedChunk = result.chunk_text\n    .substring(0, 200) // Limit for readability\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim() + (result.chunk_text.length > 200 ? '...' : '');\n    \n  return {\n    rank: index + 1,\n    videoId: result.video_id,\n    videoTitle: result.video_title,\n    youtubeId: result.youtube_id,\n    youtubeUrl,\n    chunkText: formattedChunk,\n    fullChunkText: result.chunk_text,\n    chunkIndex: result.chunk_index,\n    startChar: result.start_char,\n    endChar: result.end_char,\n    relevanceScore: Math.round(relevanceScore * 100) / 100,\n    similarityDistance: result.similarity_score,\n    estimatedTimestamp,\n    duration: result.duration,\n    indexedAt: result.indexed_at\n  };\n});\n\n// Helper function to estimate timestamp from character position\nfunction estimateTimestamp(startChar, endChar, duration) {\n  // This is a rough estimation - in production you'd want\n  // to store actual timestamps with each chunk\n  const avgCharsPerMinute = 1000; // Approximate\n  const estimatedMinutes = startChar / avgCharsPerMinute;\n  const minutes = Math.floor(estimatedMinutes);\n  const seconds = Math.floor((estimatedMinutes - minutes) * 60);\n  \n  return `${minutes}:${seconds.toString().padStart(2, '0')}`;\n}\n\n// Create comprehensive search response\nconst searchResponse = {\n  success: true,\n  query: {\n    original: searchRequest.originalQuery,\n    enhanced: searchRequest.enhancedQuery,\n    processed: true\n  },\n  results: processedResults,\n  metadata: {\n    totalResults: processedResults.length,\n    searchLimit: searchRequest.searchLimit,\n    similarityThreshold: searchRequest.similarityThreshold,\n    highestRelevance: processedResults[0]?.relevanceScore || 0,\n    lowestRelevance: processedResults[processedResults.length - 1]?.relevanceScore || 0,\n    averageRelevance: processedResults.reduce((sum, r) => sum + r.relevanceScore, 0) / processedResults.length || 0\n  },\n  performance: {\n    embeddingTokens: searchRequest.embeddingTokens,\n    processingTime: Date.now() - new Date(searchRequest.timestamp).getTime(),\n    searchTime: Date.now() - new Date(searchRequest.searchTimestamp).getTime()\n  },\n  requestId: searchRequest.requestId,\n  timestamp: new Date().toISOString()\n};\n\nconsole.log(`‚úÖ Search completed: ${processedResults.length} results, avg relevance: ${searchResponse.metadata.averageRelevance.toFixed(2)}%`);\n\nreturn [{ json: searchResponse }];"
      },
      "id": "results-processor",
      "name": "üìä Results Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 300]
    },
    {
      "parameters": {
        "content": "üìä **SEARCH RESULTS PROCESSING**\n\n**Purpose**: Formats and enhances raw search results\n\n**Result Enhancement**:\n- Relevance score calculation (0-100%)\n- YouTube URL generation\n- Timestamp estimation\n- Text formatting and truncation\n- Ranking and sorting\n\n**Metadata Generation**:\n- Search performance metrics\n- Result quality statistics\n- Processing time tracking\n- Relevance distribution analysis\n\n**Response Structure**:\n```json\n{\n  \"success\": true,\n  \"results\": [\n    {\n      \"rank\": 1,\n      \"videoTitle\": \"Roblox Scripting Basics\",\n      \"relevanceScore\": 94.5,\n      \"chunkText\": \"To create a script...\",\n      \"estimatedTimestamp\": \"5:30\"\n    }\n  ],\n  \"metadata\": { ... },\n  \"performance\": { ... }\n}\n```",
        "height": 340,
        "width": 300,
        "color": 8
      },
      "id": "sticky-processing",
      "name": "üìä Processing Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1300, -60]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Semantic-Search",
                "value": "Blox-Wizard-v1.0"
              }
            ]
          }
        }
      },
      "id": "webhook-response",
      "name": "üì§ Send Search Results",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1520, 300]
    },
    {
      "parameters": {
        "content": "üì§ **SEARCH RESPONSE DELIVERY**\n\n**Purpose**: Sends formatted search results back to client\n\n**Response Headers**:\n- Content-Type: application/json\n- X-Semantic-Search: Version identifier\n\n**Performance Targets**:\n- Total response time: < 2 seconds\n- Embedding generation: ~500ms\n- Vector search: < 100ms\n- Result processing: < 50ms\n\n**Quality Metrics**:\n- Average relevance: > 80%\n- Result coverage: 5-10 relevant chunks\n- Video diversity: Multiple sources\n- Context richness: Full chunk context\n\n**Integration Points**:\n- Called by Master Orchestrator\n- Feeds into Answer Generator\n- Supports chat interface\n- Analytics tracking ready",
        "height": 280,
        "width": 300,
        "color": 1
      },
      "id": "sticky-response",
      "name": "üì§ Response Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1520, 20]
    }
  ],
  "connections": {
    "üîç Semantic Search Webhook": {
      "main": [
        [
          {
            "node": "üîç Query Enhancement",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîç Query Enhancement": {
      "main": [
        [
          {
            "node": "ü§ñ Query Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ü§ñ Query Embedding": {
      "main": [
        [
          {
            "node": "üóÑÔ∏è Search Preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üóÑÔ∏è Search Preparation": {
      "main": [
        [
          {
            "node": "üîé Vector Similarity Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîé Vector Similarity Search": {
      "main": [
        [
          {
            "node": "üìä Results Processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Results Processor": {
      "main": [
        [
          {
            "node": "üì§ Send Search Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-01T12:00:00.000Z",
      "updatedAt": "2025-01-01T12:00:00.000Z",
      "id": "knowledge-engine",
      "name": "knowledge-engine"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-01T12:00:00.000Z",
  "versionId": "1"
}