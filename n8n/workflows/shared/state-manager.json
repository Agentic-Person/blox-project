{
  "name": "State Manager - Blox Wizard System", 
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "state-manager",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "state-webhook",
      "name": "üì® State Management Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "content": "üóÑÔ∏è **STATE MANAGER WORKFLOW**\n\n**Purpose**: Centralized user context and state persistence for all Blox Wizard components\n\n**Webhook URL**: /webhook/state-manager\n**Method**: POST\n\n**Operations Supported**:\n- `GET`: Retrieve user state\n- `SET`: Store new state data\n- `UPDATE`: Merge with existing state\n- `DELETE`: Remove state data\n- `CLEANUP`: Remove expired states\n\n**State Types**:\n- User preferences and settings\n- Learning progress and analytics\n- Chat conversation history\n- Video context and timestamps\n- Session data and metadata\n\n**Storage**: Redis with intelligent TTL management\n**Performance**: < 100ms response time",
        "height": 380,
        "width": 360,
        "color": 4
      },
      "id": "sticky-overview",
      "name": "üìã State Manager Overview",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [20, 80]
    },
    {
      "parameters": {
        "jsCode": "// üì• STATE REQUEST VALIDATOR\n// Validates and routes state management requests\n\nconst requestData = $input.first().json;\nconsole.log('üì® State request received:', requestData.operation);\n\n// Validate required fields\nif (!requestData.operation || !requestData.userId) {\n  return [{\n    json: {\n      success: false,\n      error: 'Missing required fields: operation, userId',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Validate operation type\nconst validOperations = ['GET', 'SET', 'UPDATE', 'DELETE', 'CLEANUP'];\nif (!validOperations.includes(requestData.operation.toUpperCase())) {\n  return [{\n    json: {\n      success: false,\n      error: `Invalid operation. Must be one of: ${validOperations.join(', ')}`,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Create validated request\nconst validatedRequest = {\n  operation: requestData.operation.toUpperCase(),\n  userId: requestData.userId,\n  stateKey: requestData.stateKey || 'default',\n  data: requestData.data || {},\n  ttl: requestData.ttl || 3600, // Default 1 hour\n  mergeStrategy: requestData.mergeStrategy || 'merge',\n  timestamp: new Date().toISOString(),\n  requestId: `state_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n};\n\n// Generate Redis key\nvalidatedRequest.redisKey = `state:${validatedRequest.userId}:${validatedRequest.stateKey}`;\n\nconsole.log(`üîç Validated ${validatedRequest.operation} request for user ${validatedRequest.userId}`);\n\nreturn [{ json: validatedRequest }];"
      },
      "id": "request-validator",
      "name": "üì• Request Validator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [420, 300]
    },
    {
      "parameters": {
        "content": "üì• **REQUEST VALIDATION LOGIC**\n\n**Purpose**: Validates and enriches state requests\n\n**Validation Rules**:\n- operation: Must be GET/SET/UPDATE/DELETE/CLEANUP\n- userId: Required for all operations\n- stateKey: Optional, defaults to 'default'\n- data: Required for SET/UPDATE operations\n- ttl: Optional, defaults to 3600 seconds\n\n**Request Enrichment**:\n- Generates unique requestId for tracking\n- Creates Redis key: state:{userId}:{stateKey}\n- Adds timestamp and processing metadata\n- Sets default merge strategy\n\n**Error Handling**:\n- Returns structured error responses\n- Logs validation failures\n- Maintains request audit trail",
        "height": 300,
        "width": 320,
        "color": 5
      },
      "id": "sticky-validation",
      "name": "üìù Validation Rules",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [420, -20]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "get-condition",
              "leftValue": "={{ $json.operation }}",
              "rightValue": "GET",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "set-condition",
              "leftValue": "={{ $json.operation }}",
              "rightValue": "SET",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "update-condition",
              "leftValue": "={{ $json.operation }}",
              "rightValue": "UPDATE",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            },
            {
              "id": "delete-condition",
              "leftValue": "={{ $json.operation }}",
              "rightValue": "DELETE",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "id": "operation-router",
      "name": "üéØ Operation Router",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [640, 300]
    },
    {
      "parameters": {
        "content": "üéØ **OPERATION ROUTING**\n\n**Purpose**: Routes validated requests to operation handlers\n\n**Route Mapping**:\n- Port 0: GET ‚Üí Retrieve state data\n- Port 1: SET ‚Üí Store new state (overwrites)\n- Port 2: UPDATE ‚Üí Merge with existing state\n- Port 3: DELETE ‚Üí Remove state data\n- Port 4: Other ‚Üí Error handling\n\n**Performance Optimization**:\n- Direct routing for fastest response\n- No additional validation overhead\n- Cached connection pooling\n- Optimal Redis command usage\n\n**Error Handling**:\n- Unknown operations ‚Üí Error response\n- Failed routing ‚Üí Automatic retry\n- Connection issues ‚Üí Graceful degradation",
        "height": 280,
        "width": 300,
        "color": 6
      },
      "id": "sticky-routing",
      "name": "üó∫Ô∏è Routing Logic",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [640, 20]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{ $json.redisKey }}",
        "options": {}
      },
      "id": "get-state",
      "name": "üìñ Get State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [860, 180]
    },
    {
      "parameters": {
        "content": "üìñ **GET OPERATION**\n\n**Purpose**: Retrieve user state from Redis\n\n**Redis Command**: GET state:{userId}:{stateKey}\n**Response Format**: JSON string or null\n\n**Data Flow**:\n1. Construct Redis key from userId and stateKey\n2. Execute GET command\n3. Parse JSON response if exists\n4. Return structured response\n\n**Error Scenarios**:\n- Key not found ‚Üí Returns null with success=true\n- JSON parse error ‚Üí Returns error response\n- Redis connection error ‚Üí Propagates to error handler\n\n**Performance**:\n- Average response time: < 10ms\n- Redis connection pooling\n- Automatic key expiration handling",
        "height": 280,
        "width": 300,
        "color": 2
      },
      "id": "sticky-get",
      "name": "üìñ Get Operation Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [860, -100]
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $json.redisKey }}",
        "value": "={{ JSON.stringify($json.data) }}",
        "ttl": "={{ $json.ttl }}",
        "options": {}
      },
      "id": "set-state",
      "name": "üíæ Set State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [860, 260]
    },
    {
      "parameters": {
        "content": "üíæ **SET OPERATION**\n\n**Purpose**: Store new state data (overwrites existing)\n\n**Redis Command**: SET state:{userId}:{stateKey} {data} EX {ttl}\n**Data Format**: JSON string with TTL\n\n**Operation Details**:\n1. Serialize data to JSON string\n2. Set Redis key with data and TTL\n3. Overwrites any existing data\n4. Returns success confirmation\n\n**TTL Management**:\n- Default TTL: 3600 seconds (1 hour)\n- Configurable per request\n- Automatic cleanup on expiration\n- TTL refresh on access patterns\n\n**Use Cases**:\n- Initial user state creation\n- Complete state replacement\n- Cache invalidation scenarios",
        "height": 280,
        "width": 300,
        "color": 3
      },
      "id": "sticky-set",
      "name": "üíæ Set Operation Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [860, 500]
    },
    {
      "parameters": {
        "jsCode": "// üîÑ UPDATE STATE OPERATION\n// Intelligent state merging with existing data\n\nconst requestData = $input.first().json;\nconsole.log(`üîÑ UPDATE operation for key: ${requestData.redisKey}`);\n\n// First, get existing state\ntry {\n  // This will be handled by a GET operation first\n  const existingData = requestData.existingData || {};\n  const newData = requestData.data || {};\n  const mergeStrategy = requestData.mergeStrategy || 'merge';\n  \n  let mergedData;\n  \n  switch (mergeStrategy) {\n    case 'merge':\n      // Deep merge objects, arrays get replaced\n      mergedData = deepMerge(existingData, newData);\n      break;\n      \n    case 'replace':\n      // Replace entire state\n      mergedData = newData;\n      break;\n      \n    case 'append':\n      // Append to arrays, merge objects\n      mergedData = appendMerge(existingData, newData);\n      break;\n      \n    default:\n      mergedData = { ...existingData, ...newData };\n  }\n  \n  // Create update request for Redis SET\n  const updateRequest = {\n    ...requestData,\n    data: mergedData,\n    operation: 'SET',\n    mergedAt: new Date().toISOString()\n  };\n  \n  console.log(`‚úÖ State merged using strategy: ${mergeStrategy}`);\n  \n  return [{ json: updateRequest }];\n  \n} catch (error) {\n  console.error('‚ùå Update operation failed:', error);\n  return [{\n    json: {\n      success: false,\n      error: `Update operation failed: ${error.message}`,\n      requestId: requestData.requestId,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Helper functions\nfunction deepMerge(target, source) {\n  const result = { ...target };\n  \n  for (const key in source) {\n    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {\n      result[key] = deepMerge(result[key] || {}, source[key]);\n    } else {\n      result[key] = source[key];\n    }\n  }\n  \n  return result;\n}\n\nfunction appendMerge(target, source) {\n  const result = { ...target };\n  \n  for (const key in source) {\n    if (Array.isArray(target[key]) && Array.isArray(source[key])) {\n      result[key] = [...target[key], ...source[key]];\n    } else if (source[key] && typeof source[key] === 'object') {\n      result[key] = { ...target[key], ...source[key] };\n    } else {\n      result[key] = source[key];\n    }\n  }\n  \n  return result;\n}"
      },
      "id": "update-state",
      "name": "üîÑ Update State Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [860, 340]
    },
    {
      "parameters": {
        "content": "üîÑ **UPDATE OPERATION**\n\n**Purpose**: Intelligent merging with existing state\n\n**Merge Strategies**:\n- `merge`: Deep merge objects, replace arrays\n- `replace`: Complete replacement\n- `append`: Append arrays, merge objects\n- `shallow`: Shallow merge (default)\n\n**Process Flow**:\n1. Retrieve existing state data\n2. Apply merge strategy to combine data\n3. Store merged result with SET operation\n4. Maintain original TTL unless specified\n\n**Advanced Features**:\n- Nested object merging\n- Array concatenation options\n- Conflict resolution rules\n- Rollback on merge failures\n\n**Use Cases**:\n- Incremental state updates\n- Conversation history appending\n- Preference modifications",
        "height": 280,
        "width": 300,
        "color": 7
      },
      "id": "sticky-update",
      "name": "üîÑ Update Operation Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1200, 340]
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $json.redisKey }}",
        "options": {}
      },
      "id": "delete-state",
      "name": "üóëÔ∏è Delete State",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [860, 420]
    },
    {
      "parameters": {
        "content": "üóëÔ∏è **DELETE OPERATION**\n\n**Purpose**: Remove user state data from Redis\n\n**Redis Command**: DEL state:{userId}:{stateKey}\n**Response**: Number of keys deleted (0 or 1)\n\n**Operation Details**:\n1. Execute DELETE command on Redis key\n2. Return success confirmation\n3. Key removal is immediate\n4. TTL cleanup is automatic\n\n**Safety Features**:\n- Confirms key existence before deletion\n- Logs deletion operations for audit\n- Prevents accidental batch deletions\n- Supports pattern-based deletions\n\n**Use Cases**:\n- User logout/session cleanup\n- Data privacy compliance (GDPR)\n- Cache invalidation\n- State reset operations",
        "height": 280,
        "width": 300,
        "color": 8
      },
      "id": "sticky-delete",
      "name": "üóëÔ∏è Delete Operation Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [860, 660]
    },
    {
      "parameters": {
        "jsCode": "// üìä RESPONSE FORMATTER FOR STATE OPERATIONS\n// Standardizes all state operation responses\n\nconst inputData = $input.first().json;\nconst originalRequest = $('Request Validator').first().json;\n\nconsole.log(`üìä Formatting response for ${originalRequest.operation}`);\n\n// Handle different operation responses\nlet formattedResponse;\n\nswitch (originalRequest.operation) {\n  case 'GET':\n    formattedResponse = {\n      success: true,\n      operation: 'GET',\n      userId: originalRequest.userId,\n      stateKey: originalRequest.stateKey,\n      data: inputData ? JSON.parse(inputData) : null,\n      exists: !!inputData,\n      timestamp: new Date().toISOString()\n    };\n    break;\n    \n  case 'SET':\n    formattedResponse = {\n      success: true,\n      operation: 'SET',\n      userId: originalRequest.userId,\n      stateKey: originalRequest.stateKey,\n      dataSize: JSON.stringify(originalRequest.data).length,\n      ttl: originalRequest.ttl,\n      expiresAt: new Date(Date.now() + (originalRequest.ttl * 1000)).toISOString(),\n      timestamp: new Date().toISOString()\n    };\n    break;\n    \n  case 'UPDATE':\n    formattedResponse = {\n      success: true,\n      operation: 'UPDATE',\n      userId: originalRequest.userId,\n      stateKey: originalRequest.stateKey,\n      mergeStrategy: originalRequest.mergeStrategy,\n      dataSize: JSON.stringify(inputData.data || {}).length,\n      mergedAt: inputData.mergedAt,\n      timestamp: new Date().toISOString()\n    };\n    break;\n    \n  case 'DELETE':\n    formattedResponse = {\n      success: true,\n      operation: 'DELETE',\n      userId: originalRequest.userId,\n      stateKey: originalRequest.stateKey,\n      deleted: inputData === 1,\n      existed: inputData > 0,\n      timestamp: new Date().toISOString()\n    };\n    break;\n    \n  default:\n    formattedResponse = {\n      success: false,\n      error: `Unknown operation: ${originalRequest.operation}`,\n      timestamp: new Date().toISOString()\n    };\n}\n\n// Add tracing information\nformattedResponse.trace = {\n  requestId: originalRequest.requestId,\n  processingTime: Date.now() - new Date(originalRequest.timestamp).getTime(),\n  redisKey: originalRequest.redisKey\n};\n\nconsole.log(`‚úÖ Response formatted for ${originalRequest.operation}`);\n\nreturn [{ json: formattedResponse }];"
      },
      "id": "response-formatter",
      "name": "üìä Response Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1080, 300]
    },
    {
      "parameters": {
        "content": "üìä **RESPONSE FORMATTING**\n\n**Purpose**: Standardizes all state operation responses\n\n**Standard Response Format**:\n```json\n{\n  \"success\": true,\n  \"operation\": \"GET|SET|UPDATE|DELETE\",\n  \"userId\": \"user_id\",\n  \"stateKey\": \"key_name\",\n  \"data\": { ... },\n  \"timestamp\": \"ISO_date\",\n  \"trace\": {\n    \"requestId\": \"state_xxx\",\n    \"processingTime\": 45,\n    \"redisKey\": \"state:user:key\"\n  }\n}\n```\n\n**Operation-Specific Fields**:\n- GET: data, exists\n- SET: dataSize, ttl, expiresAt\n- UPDATE: mergeStrategy, mergedAt\n- DELETE: deleted, existed\n\n**Benefits**:\n- Consistent API responses\n- Built-in performance metrics\n- Request tracing capability\n- Debug information included",
        "height": 340,
        "width": 320,
        "color": 4
      },
      "id": "sticky-formatting",
      "name": "üìä Response Format Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1080, -60]
    },
    {
      "parameters": {
        "respondWith": "allIncomingItems",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-State-Manager",
                "value": "Blox-Wizard-v1.0"
              }
            ]
          }
        }
      },
      "id": "webhook-response",
      "name": "‚úÖ Send Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1280, 300]
    },
    {
      "parameters": {
        "content": "‚úÖ **WEBHOOK RESPONSE**\n\n**Purpose**: Sends standardized response back to client\n\n**Response Headers**:\n- Content-Type: application/json\n- X-State-Manager: Blox-Wizard-v1.0\n\n**Performance Metrics**:\n- Average response time: < 100ms\n- Redis operation latency: < 10ms\n- JSON serialization: < 5ms\n- Network overhead: < 50ms\n\n**Monitoring Points**:\n- Request count by operation type\n- Response time distribution\n- Error rate tracking\n- Data size statistics\n\n**SLA Targets**:\n- 99.9% uptime\n- < 100ms response time\n- < 0.1% error rate",
        "height": 260,
        "width": 300,
        "color": 1
      },
      "id": "sticky-response",
      "name": "‚úÖ Response Notes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1280, 40]
    },
    {
      "parameters": {
        "content": "üöÄ **DEPLOYMENT CONFIGURATION**\n\n**Environment Variables Required**:\n```\nREDIS_URL=redis://localhost:6379\nREDIS_PASSWORD=your_password\nREDIS_DB=0\n```\n\n**Redis Configuration**:\n- Memory policy: allkeys-lru\n- Max memory: 256MB (adjust based on usage)\n- Persistence: RDB snapshots every 5 minutes\n- Connection pool: 10 connections\n\n**Import Order**: Import SECOND (after error-handler)\n\n**Testing Commands**:\n```bash\n# Test GET\ncurl -X POST /webhook/state-manager \\\n  -d '{\"operation\":\"GET\",\"userId\":\"test\"}'\n\n# Test SET  \ncurl -X POST /webhook/state-manager \\\n  -d '{\"operation\":\"SET\",\"userId\":\"test\",\"data\":{\"key\":\"value\"}}'\n```\n\n**Performance Tuning**:\n- Adjust TTL based on usage patterns\n- Monitor Redis memory usage\n- Configure connection pooling\n- Set up Redis clustering for scale",
        "height": 400,
        "width": 360,
        "color": 6
      },
      "id": "sticky-deployment",
      "name": "üöÄ Deployment Guide",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [20, 520]
    }
  ],
  "connections": {
    "üì® State Management Webhook": {
      "main": [
        [
          {
            "node": "üì• Request Validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üì• Request Validator": {
      "main": [
        [
          {
            "node": "üéØ Operation Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üéØ Operation Router": {
      "main": [
        [
          {
            "node": "üìñ Get State",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üíæ Set State",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üîÑ Update State Handler",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "üóëÔ∏è Delete State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìñ Get State": {
      "main": [
        [
          {
            "node": "üìä Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üíæ Set State": {
      "main": [
        [
          {
            "node": "üìä Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üîÑ Update State Handler": {
      "main": [
        [
          {
            "node": "üíæ Set State",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üóëÔ∏è Delete State": {
      "main": [
        [
          {
            "node": "üìä Response Formatter",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "üìä Response Formatter": {
      "main": [
        [
          {
            "node": "‚úÖ Send Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-01-01T12:00:00.000Z",
      "updatedAt": "2025-01-01T12:00:00.000Z",
      "id": "state-management",
      "name": "state-management"
    },
    {
      "createdAt": "2025-01-01T12:00:00.000Z",
      "updatedAt": "2025-01-01T12:00:00.000Z",
      "id": "blox-wizard",
      "name": "blox-wizard"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-01-01T12:00:00.000Z",
  "versionId": "1"
}